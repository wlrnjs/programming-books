# 리액트에서의 테스트 주도 개발

리액트로 개발하다 보면 코드가 복잡하게 꼬여버리곤 합니다. 다양한 상태를 관리하고 컴포넌트를 다루며 사용자와 상호작용을 수월하게 하는 등 여러 작업을 진행하면서 안정적인 코드베이스를 유지하는 것은 쉽지 않은 일입니다. 이때 TDD가 필요합니다.

- TDD 이해하기
- 태스킹 이해하기
- 애플리케이션 요구사항 세분화
- 애플리케이션 헤드라인 구현

## 7.1 TDD 이해하기

TDD는 완전히 새로운 개념이 아닙니다. 소프트웨어 개발과 배포를 짧은 주기로 자주 진행하는 것을 권장하는 익스트림 프로그래밍(XP)에서 시작된 TDD는 1990년대 후반으로 그 뿌리를 거슬러 올라갑니다. 애자일 개발 선언의 주요 인물 중 한 명인 켄트 백은 TDD를 XP의 범위를 넘어 리액트를 포함한 다양한 개발 방법론과 프레임워크에서 널리 채택되고 있습니다.

TDD의 핵심에는 레드-그린-리팩터 루프라 불리는 매우 간단하지만 효과적인 사이클이 있습니다.

TDD를 실천할 때 필수적인 3단계 절차가 있습니다.

- **레드**: 이 단계에서는 새로운 기능 또는 기능의 수정 사항을 확인하기 위한 테스트를 작성합니다. 아직 기능 구현이 되지 않은 상태에서 작성하기 때문에 초기에는 테스트가 실패할 수밖에 없습니다. Jest와 같은 대부분의 테스트 프레임워크에서는 붉은색 텍스트로 실패를 표시합니다.
- **그린**: 이 단계에서는 테스트를 통과시키기 위한 최소한의 코드를 작성합니다. 되도록 적은 코드를 작성하여 테스트를 통과하고, 텍스트를 녹색으로 바꾸는 것으로 충분합니다.
- **리팩터**: 마지막으로 기능 동작을 유지하면서 코드를 정리합니다. 리팩터 단계에서는 기능을 그대로 유지하면서 코드의 효율성과 가독성을 높이는 작업을 진행합니다. 리팩터링이 완료된 후에도 테스트는 통과해야만 합니다.

TDD를 처음 접한다면, 전통적인 개발 방식과 달리 테스트를 실제 코드보다 먼저 작성한다는 점이 낯설게 느껴질 것입니다. 하지만 TDD는 이를 감수할 만한 여러 장점이 있습니다.

- **집중적으로 문제 해결**: 특정 기능에 대한 테스트를 먼저 작성함으로써 한 번에 하나의 문제만 집중하고 개발 부담을 덜 수 있습니다.
- **예측 가능한 다음 단계**: 테스트 주도 방식을 따르면, 다음 단계에서 해야 할 일은 늘 정해져 있습니다. 바로 테스트를 통과하는 것입니다. 이는 인지 부하를 줄여 직면한 작업 자체에 집중할 수 있게 합니다.
- **단순하고 유지보수하기 쉬운 설계**: 이 과정은 테스트를 통과하는 데 필요한 가장 단순한 코드를 작성하게 합니다. 최소한의 설계를 구성하므로 이해하고 유지보수하기 쉽습니다.
- **사고의 흐름 유지**: TDD는 코딩에 대한 구조화된 접근 방식으로 사고의 흐름을 유지하게 합니다. 이는 생산적인 코딩의 흐름을 방해하는 잦은 컨텍스트 전환을 줄여주어 하나의 작업에만 집중할 수 있게 도와줍니다.
- **자동화된 테스트 커버리지**: TDD는 애플리케이션이 탄탄한 테스트 커버리지를 이미 가지고 있음을 보장합니다. 테스트를 작업 이후에 추가하는 게 아니라 개발 과정에 포함되어 있기 때문에, 보다 안정적인 코드베이스를 만듭니다.

TDD는 애자일 방법론과 XP의 원칙에 깊은 뿌리를 둔 방법론이지만 이를 뛰어넘는 다양한 특징이 있습니다. 구조화된 레드-그린-리팩터 루프를 통해 TDD는 양질의 코드를 작성하기 위한 견고한 프레임워크를 제공합니다. TDD에 익숙해지면 문제 해결에 더욱 집중할 수 있고 예측 가능한 개발과 단순한 설계, 더 나은 생산성과 견고한 테스트 커버리지를 얻을 수 있습니다.

### 7.1.1 여러 종류의 TDD

TDD의 핵심 원칙들은 다양한 형태로 확장되었으며, 각기 다른 관점에서 테스트와 개발에 대한 최선의 접근법을 제안합니다. 여러 종류의 TDD를 알아보고 리액트 애플리케이션에 어떻게 적용할 수 있을지 살펴봅니다.

기본 TDD는 단위 테스트에 집중합니다. 이 방식은 개별 함수나 메서드와 같은 가장 작은 단위의 코드에 대해 테스트를 작성합니다. 코드베이스의 각 부분들이 처리된 상태에서 잘 동작하는지를 확인하는 것이 목표입니다. 로직과 알고리즘을 테스트하기에는 강력하지만, 특히 리액트처럼 복잡한 UI 프레임워크에서는 여러 부분이 어떻게 상호작용을 하며 동작하는지 찾아내기가 어렵습니다.

ATDD는 사용자 승인 테스트로 개발 과정을 시작하는 것을 추가하여 TDD를 확장한 것입니다. 이는 어떤 코드를 작성하기 전에 이해관계자들과 협업하여 사용자 관점에서 완료 상태를 정의합니다. 이러한 승인 테스트는 이후 기능 개발의 기초 자료로 활용합니다. ATDD는 특히 사용자가 원하는 것과 요구하는 사항들을 확실하게 반영할 수 있는 방법입니다.

사용자 승인 테스트를 작성할 때, 작은 단위 테스트 단위로 나눌 수 있습니다. 예를 들면 사용자가 시스템에 로그인하는 것은 사용자 승인 테스트의 범주지만 비밀번호 분실, 잘못된 비밀번호 또는 사용자명, 로그인 유지하기 등과 같은 기능들은 좀 더 하위 레벨의 단위 테스트를 통해 다루어야 합니다.

BDD는 TDD와 ATDD 이후에 나온 방법론으로, 애플리케이션에 주어지는 입력에 대한 반응에 주목합니다. 특정 메서드가 기대하는 결괏값을 반환하는지 체크하는 테스트를 작성하기보다 BDD 테스트는 시스템이 특정 조건에서 예상한 대로 동작하는지를 확인합니다. BDD는 테스트를 정의하는 데 보다 서술적인 언어를 사용하여 이해관계자 중 비개발자도 쉽게 이해할 수 있게 합니다.

BDD는 Cucumber라는 도구를 사용하여 일반인이 읽을 수 있는 형태로 상세한 스펙에 대해 정의합니다. Cucumber 테스트에서는 Gherkin이라고 부르는 자연어와 유사한 형태의 텍스트를 사용합니다. 피자 주문 기능에 대해 Cucumber 프레임워크를 사용하여 BDD 테스트 케이스를 작성한 예제를 살펴보겠습니다.

```javascript
기능: 피자 주문

  시나리오: 고객이 피자 한 판을 주문
    Given 피자 가게 웹사이트에 접속해 있음
    When '피자 주문' 버튼 클릭
    And '마르게리타' 피자 선택
    And 장바구니에 담기
    Then 장바구니는 1개의 '마르게리타' 피자가 있어야 함

  시나리오: 고객이 장바구니에서 피자를 제거
    ...
```

이 Gherkin 파일은 피자 주문 기능에 대해 기대하는 행동을 정의합니다. 각 줄은 단계라 부르며 테스트에서 선언문과 같다고 볼 수 있습니다. 시나리오는 수행해야 할 단계와 기대하는 결과의 관점에서 테스트의 행동을 설명합니다.

Gherkin 문법은 가독성 좋은 문서일 뿐만 아니라 실행도 가능합니다. Cucumber와 같은 도구는 Gherkin 파일을 파싱하여 이를 기반으로 테스트를 실행합니다. Gherkin 파일에 정의된 '피자 가게 웹사이트에 접속해 있음' 문장은 cypress.visit("http://pizzashop.com") 형태의 코드로 변환됩니다. 이를 통해 기능 파일에 설명한 대로 소프트웨어가 동작하는지 확실히 알 수 있고, 애플리케이션이 변경되더라도 기능을 설명하는 원천이 될 것입니다.

Gherkin 같은 BDD 명세 파일은 애플리케이션 기능 변화를 실시간으로 업데이트하는 기록 문서의 역할을 합니다. 이 문서는 새로 합류하는 팀원이나 노련한 개발자들도 애플리케이션에서 요구하는 기능들을 빠르게 이해할 수 있게 해줍니다.

### 7.1.2 사용자 가치에 집중하기

어떤 방식을 선택하든, 리액트로 작업할 때는 사용자의 시선으로 바라보는 관점이 중요합니다. 리액트 컴포넌트는 사용자와 상호작용을 하는 UI의 일부이므로, 이를 테스트에 반영해야 합니다. 개발자가 어떻게 상태를 관리하고 효율적으로 생명주기 메서드를 관리하는지 사용자는 아무 관심이 없습니다. 버튼을 클릭하면 드롭다운 영역을 보여주거나 폼 양식을 제출하면 기대한 결과가 나오는 것이 사용자에겐 중요합니다.

리액트 테스팅 라이브러리를 만든 켄트는 "소프트웨어를 사용하는 방식을 닮은 테스트일수록 더 좋은 테스트"라고 말했습니다. 이 원칙은 사용하는 프레임워크나 라이브러리의 종류와 상관없이 적용할 수 있습니다. 항상 사용자 경험에 집중해야 합니다.

세부 구현보다 상호작용의 결과에 집중하는 BDD와 ATDD 역시 사용자 중심 접근법과 같은 맥락입니다. 이 원칙에 충실하면 리액트 컴포넌트는 잘 동작할 것이며 목표대로 사용자 경험을 제공할 수 있습니다.

## 7.2 태스킹 이해하기

태스킹은 TDD 과정에서 필요한 단계로, 사용자 스토리 또는 기능을 작고 다루기 편한 태스크로 나누어 테스트 케이스의 기본 단위로 활용합니다. 태스킹의 목적은 코드로 무엇을 작성할지, 어떻게 테스트할지, 어떤 순서로 진행할지를 분명히 결정하는 데 있습니다.

큰 요구사항을 작은 단위로 쪼개면 여러 가지 장점이 있습니다.

- **명확해지는 범위**: 기능을 태스크로 나누면 무엇을 완료해야 하는지, 어떤 방법으로 접근할지 이해하기 쉬워집니다.
- **문제의 단순화**: 복잡한 문제를 작은 태스크로 나누면 다루기 용이합니다.
- **우선순위 결정**: 태스크가 나뉘면, 중요도와 논리적 구축에 따라 작업의 우선순위를 정할 수 있습니다.
- **개별 작업에 집중**: 태스킹은 작성하는 테스트가 명확하고 즉각적인 목적을 수행하도록 보장하여 TDD 사이클을 보다 효율적으로 만들어줍니다.
- **협업 증대**: 팀원들은 개별 태스크를 맡아 작업할 수 있습니다. 이때 모든 작업이 큰 단위 기능으로 결합되어 기여한다는 점을 알고 각자 작업을 진행할 수 있습니다.

태스킹을 하는 방법은 다음 과정을 살펴봅시다.

1. **사용자 스토리와 요구사항 검토**: 사용자 스토리를 검토하거나 구현해야 할 기능에 대해 이해합니다.
2. **논리적인 구성 요소 식별**: 스토리를 도메인 개념, 비즈니스 규칙, 사용자 작업의 단위와 같은 로직의 단위로 나눕니다.
3. **태스크 목록 작성**: 태스크 목록을 작성합니다. 태스크는 15분에서 30분 정도로 짧은 시간 안에 구현 가능할 만큼 작은 단위여야 합니다.
4. **태스크 순서 배열**: 태스크를 완수하기 위한 가장 논리적인 순서로 나열합니다. 모든 것이 순조롭게 오류 없이 동작하는 기본 시나리오인 '정상 흐름'으로 시작하고, 이후에 예외 케이스를 다룬 다음 오류를 처리하는 순입니다.
5. **태스크를 테스트로 처리**: 각각의 태스크 기능을 보장해주는 테스트 케이스를 식별합니다. 이 단계에서 테스트 코드를 작성할 필요는 없으며, 어떤 것들은 테스트할지를 파악하면 충분합니다.

태스킹은 늘 하던 업무의 흐름에 이미 녹아 있을 수도 있습니다. 요구사항을 관리 가능하며 순차적인 작업으로 나눠서 체계적으로 문제를 해결해 나가는 접근 방식입니다. 각 태스크는 한 시간 이내에 완료 가능한 수준이어야 합니다.

TDD의 절차는 그림을 그리는 것과 비슷합니다. 초안을 스케치할 때 연필로 기본적인 윤곽을 잡는 것은 코드의 초기 구조를 짜는 것과 같습니다. 초반에는 머릿속의 아이디어나 개념이 모호하여 잘 보이지 않지만, 그리기 시작하면 이미지가 모양을 갖추기 시작합니다. 몇몇 요소들이 더해지면서 더 자세해지고, 지속적인 개선을 통해 조정을 합니다. 각각의 작업 단계와 반복을 거치면서 점점 더 명확해지지만 최종 결과물이 정확하게 어떤 모습일지는 마지막까지 예측할 수 없습니다. 미술가가 작품을 만드는 과정처럼 TDD 또한 점진적인 개선을 통해 견고한 소프트웨어를 만들어 줍니다.

## 7.4 애플리케이션 요구사항 세분화

애플리케이션의 요구사항을 세분화하는 데 보편적으로 적용할 수 있는 정답이 있는 건 아니지만, 일반적으로 상향식과 하향식의 2가지 방식으로 나누어 볼 수 있습니다.

상향식 TDD는 작고 기초적인 기능들의 테스트 코드를 작성하고 기능을 구현하는 것부터 시작합니다. 이 접근 방식은 개별 단위 또는 클래스부터 만들어가면서 상위 컴포넌트로 결합하여 구성하기 전에 철저하게 테스트합니다. 시스템의 개별 부분들을 강력하게 검증하여 견고한 기반을 만드는 데 도움이 됩니다.

하지만, 이 방식은 개별 단위 간 상호작용에 대한 고려와 전체 시스템을 통합적으로 보는 관점이 부족한 경우, 실제 통합 작업 시 어려움을 겪게 될 수도 있습니다.

상향식 TDD 방식은 각각의 작업마다 개별 컴포넌트에 집중합니다. 컴포넌트들은 최소한의 기능에서 시작하여, 점점 세부 기능들이 추가됩니다. 테스트 케이스도 마찬가지로 기능의 요구사항에 따라 늘려 나가면서 몇몇 엣지 케이스들도 점검하기 위해 추가합니다.

하향식 TDD는 상향식 TDD와 반대로 시스템의 전체 구조와 기능부터 시작합니다. 메인 컴포넌트의 기능을 구현하는 것부터 시작하여 이후 세부적인 기능들로 점진적으로 확장해 나갑니다. 이 방식은 시스템의 주된 목적과 작업의 흐름을 초반부터 확립할 수 있고, 명확한 개발 로드맵을 알 수 있습니다. 전체 목표에 더 잘 맞는 방식으로 통합을 유도할 수 있지만, 개발되기 전인 하위 단계 컴포넌트의 동작을 파악하기 위해 임시로 스텁이나 모킹이 필요할 수 있습니다.

하향식 TDD 개발 방식에서는 개별 컴포넌트 단위가 아닌, 전체 애플리케이션에 대한 큰 그림이 있습니다. 따라서 세부적인 구현 내용과 상관없이 애플리케이션의 외부 모습을 그릴 수 있습니다.

컴포넌트가 너무 크다면 큰 단위의 컴포넌트에서 점점 작은 컴포넌트를 분리, 세분화하여 구현합니다. 당장 세세한 부분까지 잘 설계된 작은 컴포넌트가 없더라도 항상 잘 동작하는 소프트웨어가 됩니다. 즉, 언제든 작업이 중단되더라도 항상 기능의 동작을 보장한다는 것입니다.

두 방식 모두 현대 소프트웨어 개발 방법론에 크게 기여했습니다. 어느 한쪽이 절대적으로 옳다고 할 수는 없으며, 각 방식은 서로 다른 관점을 제공합니다. 따라서 개발자들은 자신의 필요와 선호도에 따라 적합한 방식을 선택할 수 있습니다.
