# 일반적인 리팩터링 기법 살펴보기

리팩터링은 특정 언어나 프레임워크를 가리지 않으며 모든 코드에 적용 가능한 개념입니다. 변수 이름 바꾸기, 함수 선언 변경하기, 함수 추출하기, 필드의 이동 등 다양한 기법이 있습니다. 이러한 기법들은 단순해 보이지만 ,이해하기 쉽고 유지보수하기 쉬운 코드를 만드는 데 매우 유용합니다.

리팩터링은 일회성 작업이 아니라 소규모로, 반복해서 수행하면서 코드 품질과 구조를 점진적으로 발전시켜 나가는 과정입니다. 튼튼하고 작업하기 쉬운 코드베이스는 반복되는 개선작업을 통해 유지할 수 있습니다.

- 리팩터링 이해하기
- 리팩터링 전 테스트 추가하기
- 변수 이름 바꾸기
- 변수 추출하기
- 반복문을 파이프라인으로 바꾸기
- 함수 추출하기
- 매개변수 객체 도입
- 조건문 분해하기
- 함수 이동하기

## 6.1 리팩터링 이해하기

리팩터링은 체계화된 절차와 방법에 따라 기존의 코드베이스에서 기능 동작의 외적인 변화 없이 구조를 개선하는 것을 의미합니다.
리팩터링은 일상적인 코딩 작업의 기본이며, 반복적이고 점진적인 소프트웨어 개발 과정의 특성상 반드시 실천해야 합니다.

리팩터링은 한 번의 대청소를 통해 완벽한 코드베이스를 만드는 것이 아니라, 작고 점진적인 개선을 오랜 시간 지속해서 수행하는 것입니다. 각각의 변화가 코드베이스의 품질을 당장 눈에 띄게 바꿔주지 않겠지만, 시간이 지나고 이러한 작은 변화들이 쌓이면 코드베이스의 구조와 가독성, 유지보수성에 큰 변화를 불러옵니다.

리팩터링은 새로운 기능을 직접 추가하는 것은 아니지만, 신규 기능들을 버그 없이 빠르게 추가하여 제공할 수 있게 하고 요구사항의 변화에 빠르고 유연하게 대처할 수 있게 합니다. 끊임 없는 리팩터링을 통해 코드를 깔끔하고 다루기 쉽게 유지할 수 있으며, 장기적으로 지속 가능한 개발 환경이 조성됩니다.

### 6.1.1 리팩터링 중 흔히 저지르는 실수

리팩터링할 때 흔하게 저지르는 실수 중 하나의 코드를 리팩터링하지 않고 구조를 바꿔버리는 것입니다. 리팩터링과 리스트럭처링은 종종 혼용되는 용어지만, 소프트웨어 개발에서는 의미가 다릅니다.

**리팩터링**은 체계화된 방법을 통해 코드베이스를 보다 깔끔하게 가독성을 높여 작업하기 편하게 개선하는 것입니다. 외적인 부분의 수정 없이 소프트웨어의 내부 구조를 변경합니다. 보통 잘게 여러 단계로 나누어 수행하며 각 리팩터링 단계에서 소프트웨어의 기능은 동일하게 유지되어야 합니다. 기능을 새로 추가하는 것이 아니라, 읽기 쉽고 유지보수하기 편하며 미래의 변경에 대비할 수 있도록 하는 것입니다.

리액트 애플리케이션을 예로 들면, 커다란 컴포넌트를 다루기 쉬운 작은 컴포넌트로 쪼개거나 복잡한 조건 분기 로직을 전략 패턴으로 대체하는 등의 작업이 될 수 있습니다.

**리스트럭처링**은 보다 광범위하고 과감한 과정입니다. 대규모의 변경을 통해 소프트웨어의 내부 구조뿐만 아니라 외부 특성까지 영향을 미칠 수 있습니다. 리스트럭처링은 소프트웨어 설계와 데이터 모델, 인터페이스 등의 변경을 포함할 수도 있습니다. 소프트웨어의 가용성을 늘리거나 성능 향상 또한 심각한 기술 부채를 해결해야 하는 경우에 주로 진행합니다.

리액트 애플리케이션에서의 리스트럭처링은 Redux에서 리액트 Context API로의 이동과 같은 상태 관리 솔루션의 변경, 라우팅과 관련된 동작의 변경, 모놀리식 아키텍처에서 마이크로 프론트엔드 아키텍처로의 변경 등이 해당됩니다.

리팩터링과 리스트럭처링 모두 코드베이스의 품질을 높이기 위한 활동이지만, 리팩터링은 보통 그 범위가 크지 않고 외부 기능의 변화가 없으며 일반적인 개발 과정의 한 작업으로 수행합니다. 반면에 리스트럭처링은 큰 범위로 이루어지며 외부 기능의 변화가 있을 수 있고, 규모가 큰 프로젝트의 일부로서 요구사항을 해결하기 위해 상당한 변경을 수행합니다.

## 6.2 리팩터링 전 테스트 추가하기

리팩터링 과정에서 기능 변화가 눈에 띄지 않아야 하므로 현재의 동작을 충분히 커버할 수 있는 테스트 코드가 있는지 확인해야 합니다.
적재적소에 테스트가 없다면 위험할 뿐만 아니라, 변경된 코드에 대해 수동적으로 계속 체크해야 하므로 비효율적입니다.

### 6.2.1 변수 이름 바꾸기

변수 이름 바꾸기는 직관적이면서도 효과적으로 코드의 가독성과 유지보수성을 높일 수 있는 리팩터링 기술입니다. 변수의 이름을 변수가 가진 목적과 데이터의 성격을 반영하여 변경하거나, 특정 네이밍 표준을 따르게 바꿀 수 있습니다.

코드를 작성하는 초기 시점의 상황에 맞게 변수의 이름을 선택하더라도, 코드가 진화하면서 변수의 목적이 바뀔 수 있습니다. 하지만 변수의 이름을 그대로 두는 경우, 이해하기 어렵고 유지보수하기 힘든 원인이 되기도 합니다. 변수의 이름을 변경하여 그 목적에 대해 더 정확하게 설명할 수 있다면 코드의 가독성이 높아집니다.

## 6.3 변수 추출하기

변수 추출하기는 코드의 가독성과 유지보수성을 높이는 보편적인 리팩터링 기법입니다. 이 과정은 값을 계산하는 코드 영역을 새로운 변수로 대체하고 원래 표현식의 결괏값을 대체하는 변수에 할당합니다. 비슷한 리팩터링 기법으로 런타임에 변경되지 않는 값을 별도로 추출하는 상수 추출하기가 있습니다.

이 기법은 특히 코드에 복잡한 표현식이나 중복된 계산식이 있을 때 유용합니다. 표현식의 일부를 의미 있는 이름의 변수로 추출하면 코드를 쉽게 이해하고 다루기 편해집니다.

## 6.4 반복문 파이프라인으로 바꾸기

반복문을 파이프라인으로 바꾸기는 말 그대로, 반복문 구조를 변환 파이프라인 구조로 바꾸는 것입니다. 일반적으로 고차 함수 또는 자바스크립트와 같은 함수형 프로그래밍 언어의 `map, filter, reduce` 등의 메서드를 사용합니다.

자바스크립트의 경우 배열의 프로토타입 메서드로 map, filter와 reduce를 지원하며, 메서드 체이닝 기법으로 여러 메서드를 파이프라인의 형태로 구성할 수 있습니다. 각각의 메서드는 함수를 인자로 받아 이 함수를 배열의 요소에 각각 적용하여, 효과적으로 배열의 데이터 형태를 변환할 수 있습니다.

하지만 반복문을 파이프라인으로 대체하는 것은 코드를 깔끔하게 해주고 가독성을 높여줄 수 있지만, 특히 대용량의 데이터 세트를 다룰 때는 효과적인 선택이 아닐 수도 있습니다. 따라서 모든 리팩터링과 마찬가지로, 대용량의 데이터 세트를 반복해서 다뤄야 하는 경우 가독성, 유지보수성과 성능 요구사항을 균형 있게 고려해야 합니다.

for 루프를 사용한 코드는 reduce 함수로 바꿀 수 있습니다. 또한 reduce를 사용함으로써 인덱스로 사용할 변수를 추가로 정의하거나, 반복문 수행을 위해 필요한 추가 코드를 작성할 필요가 없습니다.

## 6.5 함수 추출하기

함수 추출하기는 크고 복잡한 함수를 작고 다루기 쉽게 분리하여 코드의 가독성과 유지보수성을 높여주는 리팩터링 기법입니다.

여러 동작을 수행하는 함수를 예로 들어보겠습니다. 데이터를 검증하고 계산을 수행한 후 결과 로깅 혹은 상태 업데이트를 하는 등의 다양한 역할을 하나의 함수가 맡으면 길고 복잡하여 이해하기 쉽지 않습니다. 함수 추출 리팩터링은 개별적인 기능들을 식별하고 별도의 함수로 분리한 후, 원래 함수에서 새로 만든 함수를 호출하는 과정입니다.

이 기법의 장점은 코드 자체가 문서가 될 수 있다는 점입니다. 함수의 일부를 새로운 함수로 추출하고 의미를 담은 이름으로 지으면, 함수 이름 자체가 그 기능을 설명할 수 있기 때문에 코드를 이해하기 쉬워집니다. 또한 작게 나뉜 함수는 필요하다면 다른 곳에서 재사용할 수 있기 때문에 코드 재사용성 또한 높아집니다.

## 6.6 매개변수 객체 도입

매개변수 객체 도입은 함수가 많은 수의 매개변수를 가지거나, 여러 개의 함수가 같은 매개변수를 공유할 때 사용하는 리팩터링 기법입니다. 이 기법은 연관된 매개변수들을 하나의 객체로 묶고, 이 객체를 함수에 인자로 전달합니다.

함수에서 수많은 매개변수는 헷갈리고 다루기 어렵습니다. 관련된 매개변수를 하나의 객체로 묶어주면 코드의 가독성이 높아지고 함수의 역할을 이해하기 쉬우며, 함수 호출이 단순하고 깔끔해집니다. 또한 같은 그룹의 매개변수가 여러 함수 호출에서 사용될 경우, 매개변수를 잘못된 순서로 전달할 가능성을 줄여줍니다.

## 6.7 조건문 분해하기

조건문 분해하기는 if-else나 switch와 같이 조건에 따라 분기하는 로직을 별도의 함수로 추출하는 리팩터링 기법입니다. 이 기법은 코드를 이해하기 쉽게 해주고 가독성을 높여줍니다.

조건문인 if절과 else절을 별도의 함수로 나누고, 각각이 지닌 기능 또는 그것이 무엇을 확인하는지 나타낼 수 있도록 이름을 정해줍니다. 주석이 필요할 수도 있는 코드를 이름이 잘 지어진 함수로 대체하여, 코드만 보고도 이해할 수 있게 하는 리팩터링 기법입니다.

```typescript
function isDiscountEligible(item: Item) {
  return item.quantity > 10;
}

function applyDiscountIfEligible(item: Item, subTotal: number) {
  return isDiscountEligible(item) ? subTotal * DISCOUNT_RATE : subTotal;
}
```

로직을 추출하여 다른 함수로 분리하는 것은 함수 호출이 추가로 발생하므로 다소 불필요하게 보일 수는 있지만, 코드의 가독성과 재사용성을 높여줍니다.

작은 함수를 추출한 후 현재 파일에 그대로 두지 않고, 별도의 모듈로 위치를 바꾸고 필요할 때 불러와서 사용할 수 있습니다. 이는 기존의 모듈을 작게 줄여주고 가독성을 높여줍니다.

## 6.8 함수 이동하기

함수 이동은 함수의 위치를 좀 더 적절한 곳으로 옮기는 것을 뜻합니다. 같은 클래스 안에서 이동할 수 있으며, 다른 클래스로의 이동 또는 별도의 모듈로의 이동도 가능합니다. 이 리팩터링의 목적은 기능들이 논리적으로 가장 알맞은 곳에 있게 하여, 가독성과 유지보수성을 높이고 코드를 구조화하는 것입니다.

이러한 종류의 리팩터링은 클래스의 책임이 늘어나면서 진화할 때 필요합니다. 어떤 함수는 다른 클래스에 위치하는 것이 더 알맞을 수도 있고, 클래스 내의 연관된 함수들을 묶어 별도의 클래스나 모듈로 만드는 것이 나을 수도 있습니다.

함수 이동 리팩터링 기법은 함수를 기능의 연관성이 높거나 필요한 곳으로 옮김으로써 클래스의 복잡도를 낮출 수 있습니다. 이는 연관된 코드가 함께 위치하게 하여 코드 응집도를 높여줍니다. 또한 서로 다른 코드 간의 불필요한 상호 의존관계를 낮출 수 있습니다.

## 요약

의미를 잘 드러내는 변수 이름으로 바꾸어 코드의 가독성을 높이는 변수 이름 바꾸기, 복잡한 표현식을 작고 다루기 쉬운 부분으로 나누어 단순화하는 변수 추출하기, for, while 반복문을 더욱 간결하고 명확한 map, filter, reduce 등의 고차 함수로 변환하는 반복문을 파이프라인으로 바꾸기 등이 있습니다.

함수 추출하기는 큰 함수를 하나의 명확한 책임을 맡는 작은 단위로 분리하여 코드의 모듈화와 재사용성을 높여주며, 매개변수 객체 도입은 관련 있는 여러 매개변수를 하나의 객체로 묶어 함수의 복잡도를 줄일 수 있습니다. 조건문 분해하기는 복잡한 조건문 로직을 별도의 함수로 나누어 가독성을 높이고, 함수 이동하기는 코드베이스에서 논리적으로 가장 적절한 위치로 함수를 옮김으로써 코드 간에 높은 응집도와 낮은 의존관계를 만듭니다.
