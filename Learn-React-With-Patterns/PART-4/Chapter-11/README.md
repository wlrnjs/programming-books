# 리액트 계층 구조 애플리케이션

리액트 애플리케이션이 점차 커지고 복잡해지면 코드를 효율적으로 관리하기 어려워집니다. 기능은 선형적으로 추가되지만, 코드의 복잡도는 기하급수적으로 증가하여 읽는 것뿐만 아니라 테스트와 유지보수도 어려워집니다. 계층 구조는 백엔드 시스템뿐만 아니라 클라이언트 애플리케이션 개발에도 유용한 설계 방식입니다.

애플리케이션을 계층화하면 핵심 문제들을 해결할 수 있습니다.

- 관심사 분리: 서로 다른 계층은 각기 다른 책임을 다루게 되므로 코드베이스를 쉽게 이해하고 찾아볼 수 있습니다.
- 높은 재사용성: 비즈니스 로직과 데이터 모델을 애플리케이션 전반에서 재사용하기 쉬워집니다.
- 테스트 용이성: 계층 구조는 단위 테스트와 통합 테스트를 작성하기 수월하게 하므로 더욱 탄탄한 애플리케이션을 만들 수 있습니다.
- 유지보수성: 계층 구조로 설계하면 애플리케이션이 커지더라도 기능을 추가하기가 수월합니다.

## 11.1 리액트 애플리케이션의 진화

애플리케이션의 규모에 따라 각기 다른 전략이 필요합니다. 소규모 프로젝트나 일회성 프로젝트의 경우, 모든 로직을 리액트 컴포넌트에 작성할 수 있습니다. 이러한 경우, 하나 또는 몇 개의 컴포넌트만으로도 충분합니다. 이렇게 단순한 역할을 하는 리액트 컴포넌트 코드는 HTML과 유사해 보이는데, 몇몇 변수나 상태만으로도 페이지를 동적으로 만들 수 있고 전체적으로 코드를 이해하거나 수정하기 쉽습니다.

하지만 애플리케이션의 코드베이스가 커지면서 체계화되지 않은 코드들이 계속 추가되면, 유지보수가 어려운 상태가 됩니다. 이렇게 되면 개발자가 코드를 읽고 이해하는 데 많은 시간이 소요되어, 작은 기능을 추가하는 것조차 오래 걸리게 됩니다.

### 11.1.1 단일 컴포넌트 애플리케이션

단일 컴포넌트는 원격 서버로부터 데이터를 가져오고 내부 상태를 관리하며 도메인 로직 처리, 렌더링과 같은 다양한 작업을 수행합니다. 이러한 방식은 하나의 폼을 다루거나 다른 프레임워크에서 리액트로 전환하는 과정을 설명하고 이해시키고자 하는 경우에 적합합니다.

하지만 모든 기능을 하나의 컴포넌트 안에 구현하면 코드를 이해하고 관리하기가 어려워집니다. 특히 아이템 목록을 순회하며 개별 컴포넌트를 생성하는 것과 같은 로직을 다룰 때는, 컴포넌트의 코드가 금세 많아지게 됩니다. 이처럼 복잡해진 컴포넌트는 더 작은 단위의 책임을 가진 여러 컴포넌트로 분리할 필요가 있습니다.

### 11.1.2 복합 컴포넌트 애플리케이션

단일 컴포넌트를 여러 개로 분할하면 각 컴포넌트의 기능 구현에 집중할 수 있다는 장점이 있습니다.

단일 컴포넌트를 복합 컴포넌트로 변경하면 컴포넌트마다 역할이 나뉘게 됩니다. 예를 들어 하나의 컴포넌트는 목록의 렌더링을 맡게 되고, 다른 컴포넌트는 개별 목록 요소를 렌더링하며, 또 다른 컴포넌트는 데이터를 가져와서 자식 컴포넌트에 전달합니다.

컴포넌트의 역할이 분명해진 것은 좋지만, 애플리케이션이 커질수록 역할이 뷰 계층을 넘어 확장됩니다. 네트워크 요청을 보내거나 뷰에서 사용할 수 있는 형태로 데이터를 가공하거나, 서버에 전달할 데이터를 모으는 등의 작업이 추가되기 때문입니다. 또한, 데이터를 가져온 후에 변환하는 로직이 필요할 수도 있습니다. 이러한 로직을 뷰 내부에 가지고 있는 것은 사용자 인터페이스와 직접 관련이 없기 때문에 적절하지 않아 보입니다. 결과적으로 어떤 컴포넌트는 내부 상태가 과도하게 늘어나서 혼란스럽게 됩니다.

### 11.1.3 훅을 이용한 분리

이러한 로직은 분리하여 다루는 것이 좋습니다. 다행히 리액트에서는 사용자가 직접 훅을 만들 수 있습니다. 훅은 상태가 바뀔 때 상태와 로직을 공유할 수 있는 좋은 방법입니다.

이 단계에서는 계산 로직들이 뷰와 훅, 기능 함수 등에 흩어져 있는 것이 일반적입니다. 구조화가 잘 되지 않으면 이후 코드 변경에 취약하여 오류를 유발할 수 있습니다. 예를 들어 렌더링을 위해 데이터를 가져왔을 때 데이터 구조가 뷰와 다르면 변환이 필요합니다. 하지만 이 변환 로직이 어디에 위치해야 하는지 명확하지 않습니다.

### 11.1.4 비즈니스 모델 분리

이렇게 로직들을 별도로 분리하며 여러 장점이 있다는 것을 알 수 있습니다. 분리를 통해 로직의 결합도를 높이고 뷰와 독립하여 구성할 수 있습니다. 또한 몇 가지 뷰 객체로 분리할 수 있습니다.

단순한 객체들을 통해 데이터를 다른 형태로 변환하기 쉬워지고, 비어 있는 값인지 확인하고 필요에 따라 기본값을 추가할 수 있습니다. 도메인 객체가 늘어날수록 상속이나 다형성을 통해 더욱 깔끔하게 만들 수도 있습니다.

### 11.1.5 계층화된 프론트엔드 애플리케이션

애플리케이션이 커지게 되면, 어떤 특정한 패턴을 찾을 수 있습니다. 사용자 인터페이스와도 관련 없고, 원격 서버, 로컬 스토리지, 캐시 등의 데이터 출처에 영향을 받지 않는 객체 집합을 찾을 수 있습니다. 이러한 객체들을 모아 별도 계층으로 분리할 수 있습니다.

뷰와 다른 부분들을 물리적으로 격리된 별도의 폴더에 분리했습니다. 만약에 모델을 수정해야 한다면 뷰 폴더를 찾아보지 않아도 되고, 반대로 뷰를 수정할 때도 모델 폴더를 찾아볼 필요가 없습니다.

이것은 애플리케이션 발전 과정에 대한 전반적인 설명이며, 코드를 최소한 어떤 방향으로 구성해야 하는지 정할 필요가 있습니다. 대규모 애플리케이션은 다양한 모듈과 기능들로 구성되어 있으며 각각 애플리케이션의 여러 관심사를 다루도록 만들어져 있습니다. 네트워크 요청을 다루는 모듈, 구글 로그인 API 또는 결제 중계 클라이언트 등과 같이 여러 데이터 공급사들의 인터페이스를 맞춰주는 모듈 등이 있습니다.

### 11.2.2 클래스 기반의 모델로 변환

클래스 기반의 모델의 장점

- **캡슐화**: 클래스는 관련된 속성과 메서드를 한 곳에 위치하게 하여 깔끔한 구조화가 가능합니다. 그리고 데이터 접근을 제한할 수 있어 제어하기 쉽고, 데이터 무결성을 유지할 수 있습니다.
- **메서드**: 메뉴 아이템과 관련된 복잡한 작업이 있을 때, 클래스가 제공하는 구조를 활용하여 데이터 조작이든 별도의 비즈니스 로직이든 상관없이 메서드를 정의할 수 있습니다.
- **상속과 다형성**: 메뉴 아이템에 상속이나 다형성 개념이 필요할 때 클래스 구조는 필수적입니다. 각각 다른 메뉴 아이템 타입을 공통의 기본 클래스에서 상속받아 필요한 행동을 재정의할 수 있습니다.
- **일관된 인터페이스**: 클래스는 특히 여러 애플리케이션 영역에서 메뉴 아이템을 다룰 때 데이터의 일관된 인터페이스를 보장합니다.
- **읽기 전용 속성**: 클래스는 읽기 전용 속성을 정의할 수 있으므로 데이터 수정을 제한할 수 있습니다. 데이터 무결성을 유지하고 불변 데이터 구조에서 작업하기 위한 필수적인 요소입니다.

## 11.4 계층 구조 알아보기

### 11.4.1 애플리케이션 계층 구조

지금까지 컴포넌트와 모델을 별도 파일로 분리하여 정리하는 법을 알아보았습니다. 그런데 프로젝트의 구조를 개선하는 것 역시 중요합니다. 책임이 분명한 기능은 서로 다른 폴더에 위치해야 애플리케이션 탐색을 간결화하고 시간을 아낄 수 있습니다.

뷰 계층에서는 순수 TSX 렌더링을 하는 간단한 태그들이 있습니다. 뷰 계층은 훅을 통해 상태와 부수 효과를 관리합니다. 반면에 모델 계층에서는 모델 객체가 비즈니스 로직, 여러 할인 전략을 전환하기 위한 알고리즘, 데이터 형태 변환 등 다양한 기능을 포함합니다. 이 구조는 관심사를 분리하여 코드를 체계적이고 재사용 가능하며 유지 관리하기 쉽게 만듭니다.

여기서 단방향 연결에 주목해야 합니다. 상위 계층은 하위 계층에 접근할 수 있지만, 그 반대는 불가능합니다. TSX는 훅을 상태 관리를 위해 사용하고 훅은 계산을 위해 모델을 사용합니다. 하지만 JSX나 훅을 모델 계층에서 사용할 수는 없습니다. 이런 계층 기술은 상위 계층에는 영향을 주지 않고 쉽게 기본 계층을 변경할 수 있게 하므로 깨끗하고 유지 관리가 쉬운 구조를 만들어 줍니다.

### 11.4.2 계층 구조의 유리한 점

- **높은 유지보수성**: 컴포넌트를 여러 세그먼트로 나누면 특정 코드 영역의 결함을 쉽게 식별하고 수정할 수 있으므로, 소요 시간을 최소화하고 수정하는 동안 새로운 버그가 발생할 가능성을 줄여줍니다.
- **모듈성 향상**: 이 구조는 모듈화되어 코드 재사용을 촉진하고 새로운 기능을 간단히 추가할 수 있게 합니다. 뷰와 같은 각 계층 안에서도 코드를 더 쉽게 합성할 수 있습니다.
- **가독성 개선**: 코드 안에서 로직을 이해하기 편하고 찾기 쉽습니다. 이는 처음 코드를 작성한 개발자 본인뿐만 아니라 같은 코드베이스에서 작업하는 다른 이들에게도 큰 장점입니다.
- **발전된 확장성**: 모듈 간의 복잡도를 줄여 애플리케이션의 확장성이 향상되고 전체 시스템에 영향을 주지 않으면서도 새로운 기능이나 변경 사항을 쉽게 도입할 수 있습니다. 시간이 지나면서 크고 복잡하게 발전할 것으로 예상되는 애플리케이션 개발에는 매우 중요한 장점입니다.
- **쉬운 기술 스택 이전**: 대부분의 프로젝트는 그럴 가능성이 낮지만, 뷰의 존재를 인식하지 못하는 순수 자바스크립트 (또는 타입스크립트) 코드로 도메인 로직을 캡슐화한 덕분에 기본 모델과 로직을 변경하지 않고 뷰 계층을 교체할 수 있습니다.
