# 리액트 안티패턴 소개

- UI 구축의 어려움에 대한 이해
- 상태 관리의 이해
- 예외 흐름 살펴보기
- 리액트의 일반적인 안티패턴 살펴보기

## 1.2 상태 관리의 이해

프론트엔드 개발에서 **상태 관리**는 복잡합니다. 대부분의 애플리케이션은 네트워크를 통해 원격 서버에서 데이터를 가져오는데, 이 데이터를 **서버 상태**라 부릅니다.
서버 상태는 일반적으로 백엔드 서버 또는 API와 같은 외부 소스에서 가져옵니다.

서버 상태는 주의하여 다루지 않으면 프론트엔드 개발을 어렵게 만들 수 있습니다. 몇 가지 주의해야 할 사항들을 소개합니다.

- **비동기 특성**: 원격 소스에서 데이터를 가져오는 것은 일반적으로 비동기 작업입니다. 특히 여러 원격 데이터를 동기화할 때 시간의 순서가 중요합니다.
- **오류 처리**: 원격 소스 연결은 때로는 실패하거나, 서버에서 오류를 응답할 수 있습니다.
- **로딩 상태**: 원격 소스에서 데이터가 도착하기를 기다리는 동안 애플리케이션은 '로딩 중' 상태를 효과적으로 다뤄야 합니다. 일반적으로 로딩 표시기 또는 실패 시 fallback UI를 표시합니다.
- **일관성**: 프론트엔드 상태를 백엔드와 동기화하는 것을 의미합니다. 실시간 애플리케이션이나 여러 사용자가 동일한 데이터를 변경하는 애플리케이션의 경우 특히 다루기 어렵습니다.
- **캐싱**: 일부 서버 상태를 로컬에 저장하면 성능을 향상시킬 수 있지만, 데이터 불일치와 무효화 같은 문제가 생길 수 있습니다. 예를 들어 원격의 데이터가 다른 사용자에 의해 변경되면 로컬 상태를 업데이트 하거나 갱신을 위해 다시 호출하는 동작이 필요하며, 이를 구현하기 위해서는 코드의 복잡도가 증가합니다.
- **업데이트 및 낙관적 UI**: 사용자가 상태를 변경하면 서버 호출이 성공했을 때 UI를 응답이 오기 전에 미리 업데이트하여 더 나은 사용자 경험을 제공할 수 있습니다. 하지만 서버 응답은 실패할 수 있으므로 프론트엔드에서 성공 이전의 상태로 되돌릴 수 있는 방법이 필요합니다.

이러한 사항들은 서버 상태를 관리하면서 겪게 될 어려움의 일부에 불과합니다.

프론트엔드에서 데이터를 즉시 저장하고 접근할 수 있다면, 개발자는 순차적인 사고를 할 수 있습니다.
즉 작업의 흐름에 따라 데이터에 접근하고 조작하므로 명확하고 순차적인 논리의 흐름으로 이어집니다. 이러한 사고는 동기적인 코드의 흐름과 유사하며, 개발 과정을 직관적으로 따라가기 쉽게 합니다.

실제로 비동기 호출은 예외 상황을 처리해 주어야 합니다. 데이터를 가져오는 동안 무엇을 표시할지, 네트워크 문제나 리소스를 사용할 수 없는 상황과 같은 다양한 오류 시나리오를 어떻게 처리할지 고민해야 합니다. 이를 위해 코드가 추가되면 코드의 복잡도는 증가하고 이해하기 어려워집니다.

예를 들어, 데이터를 가져오는 동안에는 로딩 상태로 전환하고 문제가 발생하면 오류 상태로 전환해야 합니다.

컴포넌트에서 실제 렌더링을 담당하는 코드는 JSX를 반환하는 영역과 같은 일부분에 불과합니다.
반면에, 상태 관리를 위한 코드는 함수 본문에서 거의 대부분을 차지합니다.

하지만 이는 상태 관리의 한 측면에 불과합니다. 컴포넌트 안쪽에서 상태를 유지해야 하는 로컬 상태 관리 문제도 있습니다. 예를 들어 아코디언 컴포넌트는 헤더의 삼각형 영역을 클릭하면 목록 패널을 접거나 펼칠 수 있으며 이러한 상태 또한 관리해야 합니다.

애플리케이션이 복잡해져서 상태 관리가 힘든 수준이 된다면, Redux나 Mobx와 같은 서드파티 상태 관리 라이브러리를 사용하는 것이 도움될 수 있습니다. 하지만 이는 특정 라이브러리에 대한 추가적인 학습이 필요하고, 모범 사례를 익혀야 합니다. 또한 코드 변환을 위한 부가적인 작업이 필요하므로 신중하게 고려해야 합니다. 따라서 많은 개발자가 리액트에서 기본으로 제공하는 Context API를 이용한 상태 관리를 더 선호합니다.

## 1.3 예외 흐름 탐색하기

UI를 개발할 때 모든 것이 계획한 대로 최적의 사용자 경험을 제공하는 '정상 흐름'을 우선 고려합니다. 하지만 '예외 흐름'을 무시하고 개발한 UI 컴포넌트는 생각보다 힘든 상황을 불러올 수 있습니다. 예외 흐름으로 이어지는 몇 가지 복잡한 UI 개발 사례를 소개합니다.

### 1.3.1 다른 컴포넌트에서 발생한 오류

실제 프로젝트에서 UI는 다양한 마이크로 서비스나 API에서 데이터를 가져오게 됩니다. 이 시스템들이 다운된다면, UI에서도 이에 대해 준비되어 있어야 합니다.
대체 디자인, 로딩 표시기, 오류가 발생했을 때 안내 표시와 사용자를 위한 안내 문구 등이 필요합니다.

### 1.3.2 예측하지 못한 사용자 행동

아무리 UI를 완벽하게 설계하더라도 사용자는 항상 예상하지 못한 방식으로 시스템을 사용합니다. 이러한 엣지 케이스에 대비할 수 있는 UI를 설계해야 하는데, 유효성 검사와 안전 장치를 위해 추가 구현을 하다 보면 UI 코드는 더 복잡해집니다.

'예외 흐름'에 대한 이해와 적절한 처리는 견고하고 유연하며 사용자 친화적인 인터페이스를 만드는 데 매우 중요합니다. 보다 신뢰할 수 있는 애플리케이션을 만들 수 있으며, 좀 더 세심한 사용자 경험을 제공할 수 있습니다.

## 1.4 리액트의 일반적인 안티패턴 살펴보기

소프트웨어 개발 영역에서는 언뜻 보기에 특정 문제에 대한 유익한 해결책처럼 보이는 관행과 접근 방식을 자주 접하게 됩니다.
안티패턴이라 불리는 이러한 관행들은 문제를 빠르게 해결해주는 것 같지만 사실 근본적인 문제를 이면에 숨기는 경우가 많습니다.
안티패턴에 의존할수록 코드는 더 복잡해지고 효율이 떨어지며, 심지어 해결된 줄 알았던 문제가 더 커지기도 합니다.

이러한 안티 패턴을 이해하고 인식하면 개발자가 마주할 수 있는 함정을 미리 예상하고 장기적으로 생산성을 저해하는 솔루션을 피할 수 있습니다.

### 1.4.1 Prop Drilling

prop이 부모 컴포넌트에서 자식 컴포넌트로 전달될 때 여러 개의 중간 컴포넌트를 거쳐서 전달하게 되는 Prop Drilling 현상이 나타나기 때문입니다.

이러한 방식은 코드의 복잡도를 높이고 유지보수성을 떨어뜨립니다. 여러 개의 prop이 여러 컴포넌트를 통해 전달되면 데이터 흐름에 대한 이해를 방해하고 디버깅하기 어려워질 수 있습니다.

이에 대한 잠재적인 해결책은 리액트에서 제공하는 Context API를 활용하는 것입니다.
Context API는 컴포넌트 트리의 모든 단계마다 prop을 명시적으로 전달할 필요 없이, 컴포넌트 간에 직접 데이터와 함수를 공유하는 방법을 제공합니다.

### 1.4.2 컴포넌트 내 데이터 변환

리액트에서 컴포넌트 중심의 접근 방식은 작업과 문제를 다루기 쉬운 단위로 나눠서 유지보수성을 높여줍니다. 그러나 흔히 반복되는 실수 중 하나는 컴포넌트 내부에 복잡한 데이터 변환 로직을 직접 작성하는 것입니다.

특히 외부 API나 백엔드에서 전달받은 데이터는 프론트엔드에 적합하지 않은 형태인 경우가 많습니다.
이러한 데이터를 고차 컴포넌트 또는 유틸리티 함수를 통해 처리하기보다는 컴포넌트 안에서 변환 작업을 수행하는 경우가 많습니다.

이러한 변환 작업을 컴포넌트 내부에 직접 구현하면 다음과 같은 문제가 발생합니다.

- **명확하지 않음**: 데이터 가져오기와 변환, 렌더링 작업이 하나의 컴포넌트 안에서 이루어지므로 이 컴포넌트가 어떤 역할을 하는지 알기 어렵습니다.
- **재사용성이 떨어짐**: 다른 컴포넌트에서 유사한 변환이 필요한 경우, 로직의 중복이 발생합니다.
- **테스트하기 어려움**: 테스트를 하려면 변환 로직을 고려해야 하므로 테스트 코드가 더 복잡해집니다.

이러한 안티패턴을 방지하려면 데이터 변환 로직을 컴포넌트와 분리하는 것이 좋습니다.
이는 유틸리티 함수나 사용자 정의 훅을 이용하여 보다 명확하고 모듈화 된 구조로 바꿔줍니다. 변환 로직을 컴포넌트 외부로 분리하면, 컴포넌트는 렌더링과 비즈니스 로직에 집중할 수 있으므로 더욱 유지보수하기 쉬운 코드베이스를 구축할 수 있습니다.

### 1.4.3 뷰 영역의 복잡한 로직

리액트와 같은 최신 프론트엔드 프레임워크의 장점 중 하나는 관심사를 명확하게 분리할 수 있게 해준다는 점입니다.
설계상 컴포넌트는 비즈니스 로직을 신경 쓰지 않고 프레젠테이션에 집중해야 합니다. 이는 깔끔한 관심사 분리를 방해할 뿐만 아니라, 컴포넌트가 크고 복잡해져서 테스트와 재사용을 어렵게 합니다.

컴포넌트 안에 비즈니스 로직의 일부가 포함되어 있으면 데이터를 표시하는 것뿐만 아니라 가공하는 작업도 수행하는데, 다음과 같은 문제가 있습니다.

- **재사용성**: 다른 컴포넌트에서 유사한 필터가 필요한 경우, 로직이 중복됩니다.
- **테스팅**: 렌더링뿐만 아니라 비즈니스 로직도 테스트해야 하므로 단위 테스트가 복잡해집니다.
- **유지보수성**: 애플리케이션이 커지면서 더 많은 로직이 추가되기 때문에 유지보수하기 어려워집니다.

컴포넌트를 재사용 가능하고 유지보수하기 쉽게 만들기 위해서는 관심사 분리 원칙을 지키는 것이 좋습니다. 이 원칙은 각각의 모듈 또는 함수가 애플리케이션의 하나의 기능에 대한 책임만 가져야 한다는 것입니다. 계층화된 아키텍처를 통해 비즈니스 로직과 프레젠테이션 계층을 분리하면, 코드의 각 부분이 명확한 책임을 맡게 되어 보다 모듈화되고 관리하기 쉬운 코드베이스를 구축할 수 있습니다.

### 1.4.4 테스트 부족

테스트 주도 개발(TDD)을 시작해야 합니다. TDD는 테스트 코드를 먼저 작성하고, 실제 컴포넌트 로직을 나중에 작성하는 것을 권장합니다.
장바구니를 예시로 아이템이 올바르게 추가 또는 제거되는지, 총 결제 금액이 적절하게 바뀌는지, 할인 적용과 같은 특별한 경우도 잘 대응하는지 등을 확인하는 테스트를 수행합니다.
TDD는 오류를 조기에 발견하는 것에 그치지 않고 잘 구조화되고 유지보수 가능한 코드 작성을 가능하게 합니다. 애플리케이션이 커지더라도 TDD 테스트 코드가 있다면 구현 코드 수정이나 기능 추가에도 정확성을 보장합니다.

### 1.4.5 중복된 코드

코드베이스에서 유사하거나 동일한 코드 조각이 애플리케이션의 여러 부분에 흩어져 있는 것은 흔하게 볼 수 있습니다. 중복 코드는 코드베이스를 부풀릴 뿐만 아니라, 잠재적인 문제를 가져올 수 있습니다. 버그가 발견되거나 개선이 필요할 때, 각각의 중복된 코드 모두를 변경해야 하므로 오류가 발생할 가능성이 높아집니다.

여기서 중복 배제 원칙(DRY)이 도움이 됩니다. 공통 로직을 유틸리티 함수나 고차 컴포넌트로 모아서 관리하면, 유지보수하기 편하고 가독성이 높은 코드가 되며 오류 발생 가능성이 줄어듭니다.

### 1.4.6 너무 많은 기능을 가진 컴포넌트

리액트는 재사용 가능한 모듈형 컴포넌트를 만들도록 권장합니다. 그러나 기능이 늘어나면 컴포넌트는 맡게 되는 책임이 늘어나면서 다루기 힘든 거대한 덩어리로 변할 수 있습니다.
다양한 기능을 가진 컴포넌트는 이해하기도, 유지보수하기도, 테스트하기도 어렵습니다.

만약 거대한 prop 목록이 있어서 다양한 기능을 담당하는 컴포넌트가 있다면, 이 컴포넌트는 하나의 구성 요소가 하나의 기능만을 수행해야 한다는 단일 책임 원칙에 위배됩니다.
여러 개의 역할을 수행하면 더 복잡해지고 유지보수하기 힘들어집니다. 핵심 기능을 분석하고 부가적인 지원 로직들을 더 작고 집중된 컴포넌트나 훅으로 분리해야 합니다.

### 1.4.7 안티패턴을 없애기 위한 접근 방식

널리 퍼져 있는 안티패턴을 해결하기 위해서는 다양한 디자인 패턴을 활용해야 합니다.
render prop, 고차 컴포넌트, 훅과 같은 기술은 컴포넌트가 기본적인 역할에서 벗어나지 않으면서도 그 기능을 강화할 수 있게 합니다.
계층화된 아키텍처와 관심사의 분리처럼 뼈대가 되는 패턴을 활용하면 로직과 데이터, 프레젠테이션을 일관된 방식으로 나누어 코드베이스를 간소화할 수 있습니다.
이러한 방법론은 리액트 애플리케이션의 지속가능성을 높일 뿐만 아니라 개발자들의 효과적인 팀워크를 위한 기반을 마련합니다.

인터페이스 지향 프로그래밍은 주로 인터페이스를 통해 소프트웨어 모듈 간에 발생하는 상호작용을 중심으로 소프트웨어를 구성하는 데 중점을 둡니다. 이러한 모듈화된 운영 방식은 소프트웨어 모듈을 쉽게 변경하면서 동시에 일관성을 유지할 수 있게 해줍니다.

반면에 헤드리스 컴포넌트 패러다임은 사용하는 컴포넌트에 UI 렌더링의 역할을 넘겨주므로 다양한 곳에 적용할 수 있어 재사용하기 편리합니다.

또한 TDD와 지속적인 리팩터링은 코드 품질을 높이는 강력한 도구입니다. TDD는 잠재적인 불일치에 대한 즉각적인 피드백 루프를 제공하고, 지속적인 리팩터링은 코드를 계속해서 최적화하고 개선시킵니다. 이러한 방법론은 코드 품질의 우수성을 보장하며, 미래의 코드 변경에 유연하게 대응할 수 있게 합니다.

리팩터링 영역을 공부할 때는 이러한 기술의 본질을 파악하고 가장 효과적인 지점을 찾아 적용하는 것이 중요합니다. 리팩터링 방법을 활용하여 코드의 명확성, 지속 가능성 및 전반적인 효율성을 강화할 수 있습니다.
