# 합성 패턴

합성은 이러한 문제를 해결하기 위해 체계적이고 확장 가능하며 깔끔한 코드베이스를 만들 수 있게 해주는 강력한 기술입니다. 하나의 거대한 컴포넌트에 여러 가지 기능을 만들지 않고, 작고 다루기 편한 조각으로 분리하여 다양한 방법으로 이를 조합할 수 있습니다. 이러한 접근 방식은 로직을 간소화하고 재사용성을 향상시키며 관심사를 명확하게 분리할 수 있습니다.

- 고차 컴포넌트를 통한 합성의 이해
- 리액트 훅
- 드롭다운 목록 컴포넌트 만들기
- 헤드리스 컴포넌트 패턴

## 10.1 고차 컴포넌트를 통한 합성의 이해

합성은 소프트웨어 설계 전반에서 가장 중요한 기술 중 하나이며, 다양한 수준에서 적용할 수 있습니다.

### 10.1.1 고차 함수

고차 함수는 다른 함수를 인자로 받거나, 함수를 반환하거나 또는 두 가지 특징을 모두 가진 함수를 의미합니다. 함수를 매개변수로 받을 수 있다는 것은 많은 장점이 있으며, 특히 합성을 할 때 유리합니다.

```javascript
const report = (content: string) => {
  const header = "=== Header ===";
  const footer = "=== Footer ===";

  return [header, content, footer].join("\n");
};
```

report 함수는 헤더, 제공되는 내용, 푸터를 포함하는 규격화된 리포트를 생성합니다.

만약 내용을 대문자로 출력하고 싶다면 content.toUpperCase()를 통해 쉽게 구현할 수 있습니다. 하지만 현재 상태 그대로를 원하는 사용자도 있기 때문에 report 함수에 조건문을 추가하는 방법을 통해 모든 사용자의 요구를 만족시킬 수 있습니다.

```javascript
const report = (content: string, transformer: (s: string) => string) => {
  const header = "=== Header ===";
  const footer = "=== Footer ===";

  return [header, transformer(content), footer].join("\n");
};
```

기본 transformer 함수를 제공하여, 형식에 변경이 필요하지 않은 사용자는 기존 방식 그대로 사용할 수도 있습니다.

```javascript
const report = (
  content: string,
  transformer: (s: string) => string = (s) => s
) => {
  const header = "=== Header ===";
  const footer = "=== Footer ===";

  return [header, transformer(content), footer].join("\n");
};
```

report 함수는 정의된 헤더와 푸터로 문자열을 생성하고 메인 콘텐츠를 그 사이에 넣습니다. 그리고 콘텐츠 문자와 transformer 함수는 선택적으로 전달받습니다. transformer 함수가 제공되면 콘텐츠를 수정하고, transformer 함수가 없으면 콘텐츠는 바뀌지 않습니다. 결과는 변환 작업을 수행한 내용 또는 본문 그대로의 내용이 담긴 규격화된 리포트입니다. 이것이 고차 함수가 본질적으로 어떻게 합성 가능한 코드를 작성하도록 도와주는지를 보여주는 예제입니다.

함수 합성을 통한 프로그래밍 접근 방식을 리액트 애플리케이션에도 적용할 수 있습니다. 기능을 추가하는 컴포넌트는 표준 함수로만 구현할 수 있는 것은 아닙니다. 리액트에서는 고차 컴포넌트(HOC)를 통해 이를 구현할 수 있습니다.

### 10.1.2 고차 컴포넌트

HOC는 컴포넌트를 전달받아 새로운 개선된 버전의 컴포넌트를 반환하는 함수입니다. HOC의 원리는 단순합니다. 기존의 컴포넌트에 기능을 추가할 수 있도록 하는 것입니다. 이 패턴은 특정 기능을 여러 컴포넌트에 재사용하고자 할 때 특히 유용합니다.

```javascript
const checkAuthorization = () => {
  // 권한을 확인하거나 또는 로컬스토리지를 확인해 원격 서버로 요청을 보냄
};

const withAuthorization = (Component: React.FC): React.FC => {
  return (props: any) => {
    const isAuthorized = checkAuthorization();
    return isAuthorized ? <Component {...props} /> : <Login />;
  };
};
```

이 코드 조각에서는 권한 확인을 위해 checkAuthorization 함수를 정의하였습니다. 다음으로 withAuthorization HOC를 만들었습니다. 이 HOC는 Component를 인자로 받아서 새로운 함수를 반환합니다. 반환된 함수를 렌더링할 때 권한이 있는 사용자라면 처음에 전달받은 Component를 렌더링하고, 권한이 없는 사용자인 경우에는 Login을 렌더링 합니다.

이제 로그인한 사용자만 사용할 수 있는 ProfileComponent가 있다고 생각해봅니다. withAuthorization을 통해 새로운 보안 기능이 추가된 ProfileComponent를 만들 수 있습니다.

```javascript
const Profile = withAuthorization(ProfileComponent);
```

Profile이 렌더링될 때, 먼저 사용자가 권한이 있는지 확인합니다. 권한이 있으면 Profile Component를 렌더링하고, 그렇지 않으면 Login 컴포넌트로 리다이렉트합니다.

HOC가 withAuthorization을 통해 어떻게 권한을 관리하는지 알아봤습니다.

## 10.2 리액트 훅

훅은 상태가 있는 로직을 컴포넌트에서 분리할 수 있게 하여 독립적인 테스팅과 재사용을 가능하게 해줍니다. 컴포넌트 구조를 바꾸지 않고도 상태가 있는 로직을 재사용할 수 있게 합니다. 기본적으로 훅을 사용하면 함수 컴포넌트에서 리액트의 상태 또는 기타 생명주기 기능들을 연동할 수 있습니다.

훅은 재사용이 가능한 로직을 포함하며, 컴포넌트와 분리되어 있지만 쉽게 결합할 수 있습니다. HOC를 통해 감싸는 접근법과 달리 훅은 플러그인 형태의 방식을 제공하여 리액트를 통해 가벼운 형태로 관리하기 쉽습니다. 이러한 훅의 특성은 코드 모듈화를 쉽게 해줄 뿐만 아니라, 보다 깔끔하고 직관적인 형태로 컴포넌트의 기능을 덧붙일 수 있게 해줍니다.

훅은 생각보다 다양한 기능을 제공합니다. UI와 관련된 상태를 관리하는 것뿐만 아니라, 데이터를 가져오거나 페이지 단위의 키보드 단축키 처리와 같은 전역 이벤트 핸들링 등 UI의 부수 효과를 다룰 때도 사용합니다.

## 10.4 헤드리스 컴포넌트 패턴

헤드리스 컴포넌트 패턴은 JSX 코드를 기본 로직으로부터 깔끔하게 분리하는 강력한 방법입니다. JSX로 선언적 UI를 구성하는 것은 자연스럽지만, 상태를 관리하는 것은 쉽지 않습니다. 이 문제를 해결하고자 등장한 헤드리스 컴포넌트는 상태 관리의 모든 복잡한 문제들을 떠맡으며 새로운 차원의 추상화 방법을 제시했습니다.

헤드리스 컴포넌트는 로직을 캡슐화해서 담고 있지만 렌더링과 관련된 것은 없는 함수를 뜻합니다. 렌더링 영역은 사용자에게 맡김으로써, UI 렌더링에 있어서 고도의 유연성을 제공합니다. 이 패턴은 각각 다른 형태로 나타내야 하는 영역에서 복잡한 로직을 재사용하고 싶을 때 매우 유용합니다.

다음 코드에서 useDropdownLogic 훅은 로직을 담고 있지만 UI 요소는 없습니다. MyDropdown 컴포넌트는 헤드리스 컴포넌트를 사용하여 렌더링만 담당하고 있습니다.

```javascript
function useDropdownLogic() {
  // ... 모든 드롭다운 로직
  return {
    // ... 외부에 공개되는 로직
  }
}

function MyDropdown() {
  const dropdownLogic = useDropdownLogic();
  return (
    // ... dropdownLogic을 이용하여 UI 렌더링
  );
}
```

시각적 표현 영역에서 헤드리스 컴포넌트는 얇은 인터페이스 계층으로 볼 수 있습니다. 한쪽은 JSX 뷰 영역과 상호작용하고 다른쪽은 밑부분의 데이터 영역과 상호작용을 합니다. 이 패턴은 특히 UI에서 동작과 상태 관리 측면만 시각적 표현 영역과 분리하여 다루고자 할 때 유용합니다.

HOC 또는 render prop 패턴으로 헤드리스 컴포넌트를 구현할 수 있지만, 리액트 훅을 통해 구현하는 것이 더 일반적입니다. 헤드리스 컴포넌트 패턴 안에서 공유 가능한 로직은 캡슐화되어 있고, 상태 로직의 변경 없이도 다른 UI와 자연스럽게 연결할 수 있습니다.

### 10.4.1 헤드리스 컴포넌트 패턴의 장단점

- **재사용성**: 헤드리스 컴포넌트 패턴 안에 캡슐화된 로직은 여러 컴포넌트에서 재사용할 수 있습니다. 이를 통해 코드베이스에서 중복 배제 원칙(DRY)을 강화할 수 있습니다.
- **관심사 분리**: 로직을 렌더링과 분리하기 때문에, 헤드리스 컴포넌트는 명확하게 관심사를 분리하여 유지보수하기 쉬운 코드의 기반이 됩니다.
- **유연성**: UI 구현에 필요한 동일한 핵심 로직을 공유함으로써, 서로 다른 디자인 요구사항 또는 프레임워크에 적용하기 쉽습니다.

그러나 헤드리스 컴포넌트 패턴의 주요 단점은 다음과 같습니다.

- **높은 진입장벽**: 헤드리스 컴포넌트 패턴이 익숙하지 않은 개발자들에게는 학습할 시간이 필요합니다. 이에 따라 초기 개발 속도가 늦어질 수 있습니다.
- **과도한 추상화**: 신중하게 관리하지 않으면, 헤드리스 컴포넌트로 인한 추상화는 코드를 따라가기 어렵게 만들 수 있습니다.

### 10.4.2 지원하는 라이브러리와 추가로 알아볼 내용

헤드리스 컴포넌트 패턴은 다양한 라이브러리에서 지원하고 있습니다. 몇 가지 유명한 라이브러리와 그 특징을 소개합니다.

- **React Aria**: 어도비에서 만든 접근성을 강조한 라이브러리입니다. 훅 모음을 통해 키보드 상호작용, 포커싱, Aria 애너테이션 등을 다룹니다. 접근성 높은 UI 컴포넌트를 쉽게 만들 수 있습니다.
- **Headless UI**: 스타일 요소 없이 접근성을 완벽히 지원하는 UI 컴포넌트 라이브러리로, Tailwind CSS와 통합하기 편리한 구조로 설계되었습니다. 동작과 접근성의 기반을 제공하므로 사용자는 이를 토대로 원하는 스타일의 컴포넌트를 만들 수 있습니다.
- **React Table**: 리액트에서 빠르고 확장하기 편리한 테이블과 데이터 그리드를 만들 수 있는 헤드리스 유틸리티입니다. 유연한 훅을 통해 복잡한 테이블을 쉽게 만들고 UI 영역 표현은 사용자가 마음대로 그릴 수 있습니다.
- **Downshift**: 작고 가벼운 라이브러리로 접근성이 좋고 사용자 정의가 쉬운 드롭다운과 콤보 박스 UI를 만들 수 있습니다. 렌더링 측면을 제외한 대부분의 로직을 라이브러리에서 다룹니다.

이러한 라이브러리들은 헤드리스 컴포넌트 패턴의 골격을 구현하여 지원하고 있어, 높은 수준의 상호작용과 접근성을 지원하는 UI를 쉽게 만들 수 있습니다.
