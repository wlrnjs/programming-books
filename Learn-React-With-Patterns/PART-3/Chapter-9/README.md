# 리액트 설계 원칙 적용

설계 원칙은 소프트웨어 개발에서 시간이 지나도 코드베이스와 유지보수성, 확장성, 그리고 가독성을 보장하기 위한 기본 원칙입니다. 끊임없이 변화하는 기술 환경 속에서도 설계 원칙을 준수한다면 프로젝트의 장기적인 성공을 이끌어낼 수 있으며, 버그가 빈번하게 발생하는 '코드 지옥'도 피할 수 있습니다.

리액트 애플리케이션은 라이브러리의 선언적 특성과 컴포넌트 기반의 구조로 인해 설계 원칙이 더욱 중요합니다. 리액트는 작고 독립된 컴포넌트로 복잡한 UI를 만들 수 있습니다. 이러한 모듈화된 접근 방식은 리액트의 강점이지만, 설계 원칙을 지키지 않으면 관리하기 어려운 코드가 되기 쉽습니다.

일반적인 리액트 프로젝트에서는 컴포넌트를 중첩하면서 상태와 행위를 공유하고 애플리케이션의 다른 영역에서 컴포넌트를 재사용합니다. 설계 원칙을 따르지 않으면 복잡한 의존관계로 인해 코드를 변경하기 어렵거나 읽기 어려워집니다. 예를 들어, 단일 책임 원칙(SRP)을 준수하지 않는다면 컴포넌트 테스트와 리팩터링이 어려워지고, 인터페이스 분리 원칙(ISP)을 무시하면 특정 유스 케이스에 묶여 컴포넌트의 재사용성이 떨어집니다.

- 단일 책임 원칙
- 의존관계 역전 원칙
- 명령과 조회 책임 분리 원칙

## 9.1 단일 책임 원칙

이 원칙은 다양한 프로그래밍 원칙의 기반이 되는 보편적인 개념입니다.

단일 책임 원칙의 핵심은 컴포넌트의 주요 역할을 정확히 파악하는 것입니다. 컴포넌트가 수행해야 할 핵심 기능을 분리하면, 부가적인 기능들을 리팩터링하고 추상화하기 쉬워집니다.

단일 책임 원칙은 상위 레벨의 가이드라인으로, 코드 레벨 수준에 직접 적용하기 적합합니다. 이 원칙을 구현하는 방법은 다양하지만, 특히 복잡도가 높아지는 상황에서는 어느 시점에 적용할지 잘 파악해야 합니다.

가장 많이 사용되는 2가지 기술은 render prop과 합성입니다. render prop은 리액트 컴포넌트 간 코드 공유를 위해 함수 prop을 이용하는 기술입니다. render prop으로 구현된 컴포넌트는 자체적으로 렌더링 로직을 구현하는 대신 리액트 요소를 반환하고 이를 호출하는 함수를 사용합니다. 반면에 합성은 작고 재사용 가능한 컴포넌트들을 만들어 이들을 조합해 더 복잡한 UI 요소를 만드는 기술입니다.

### 9.1.1 render prop 패턴을 통한 단일 책임 원칙 적용

간단한 함수 컴포넌트인 Title입니다.

```jsx
const Title = () => {
  return <div>Title | This is a title</div>;
};
```

이 컴포넌트는 정적인 문자열을 표시할 뿐입니다. 다른 제목을 표시하려면 title prop이 필요합니다.

```jsx
const Title = ({ title }) => {
  return <div>Title | {title}</div>;
};
```

리액트에서 render prop 패턴은 prop으로 함수를 컴포넌트에 전달합니다. 이 함수는 JSX를 반환하며, 컴포넌트 일부 영역의 렌더링을 담당하게 됩니다. 이 패턴은 부모 컴포넌트가 자식 컴포넌트의 렌더링 로직을 제어할 수 있게 하므로 컴포넌트를 더욱 유연하게 하고 재사용할 수 있게 만들어 줍니다. 특히 여러 컴포넌트로 동작을 공유할 때 유용합니다.

여기서 가장 중요한 패턴인 추상화를 눈여겨봐야 합니다. 처음에는 h2 또는 h3 태그를 헤더의 특정 구현으로만 생각했지만, 조금 더 넓은 시야에서 살펴보면 모두 리액트 컴포넌트 또는 ReactNode로 추상화하여 생각할 수 있습니다.

이를 통해 render prop 또는 자식 컴포넌트를 고차 함수로 사용하는 것의 유용함을 알 수 있습니다. 이는 단순한 기능을 넘어서 우리가 만들어낸 추상화 표현 수준을 나타냅니다. h3와 같은 특정 HTML 태그에 국한되지 않고, JSX 요소 형식이라면 제목부터 완전히 스타일링된 컴포넌트까지 어떤 것이든 전달할 수 있습니다.

render prop을 사용하여 새롭게 만든 일반화된 컴포넌트로 재사용 가능한 프레임워크를 만들었습니다. 범용적으로 사용하는 코드를 한 번만 작성했다는 것이 중요합니다.

render prop을 통한 합성은 핵심 로직을 변경하지 않고 컴포넌트 동작을 확장하거나 사용자에 맞게 지정할 수 있는 기술입니다. 각 컴포넌트가 하나의 역할을 잘 수행하기 때문에 컴포넌트를 깔끔하게 모듈화하며 테스트하기 쉽게 유지합니다.

### 9.1.2 합성을 통한 단일 책임 원칙 적용

합성은 이 책의 많은 부분에서 사용한 개념이며 그 핵심에는 단일 책임 원칙이 있습니다. 시스템의 각 부분이 제 역할을 잘 수행한다면 이를 함께 합성할 수 있습니다.

단일 책임 원칙은 하나의 책임을 잘 수행하는 컴포넌트를 만들어 유지관리가 쉽고 재사용 가능하며 유연하게 합니다.

## 9.2 의존관계 역전 원칙

의존관계 역전 원칙(DIP)은 유지보수 가능하며 유연하고 확장 가능한 소프트웨어를 만들기 위해 필요한 SOLID 5가지 원칙 중 하나로, 이 원칙은 구체적인 구현보다는 추상화에 초점을 맞춥니다.

의존관계 역전 원칙은 대규모 시스템을 구축하고 유지 관리할 때 직면하는 문제들을 해결합니다. 그중 하나는 단단하게 결합된 모듈로 인해 발생하는 문제입니다. 상위 레벨의 모듈이 하위 레벨의 모듈에 의존관계를 맺게 되면, 하위 레벨 모듈을 조금만 변경해도 광범위한 영향을 미쳐 시스템 전체의 변경이 필요합니다.

## 9.3 명령과 조회 책임 분리 원칙

명령과 조회 책임 분리 원칙(CQRS)은 소프트웨어 설계에서 메서드나 함수는 시스템의 상태를 수정하는 명령이거나 시스템 상태에 대한 정보를 조회하여 반환하는 쿼리 둘 중에 하나여야 하며, 2가지가 동시에 수행되지 않아야 한다는 원칙입니다.

명령 (또는 수정) 메서드는 액션 또는 객체의 상태 변경을 수행하며 값을 반환하지 않습니다. 반면에 조회 메서드는 객체의 상태를 변경 없이 읽습니다. 명령과 조회를 분리하면 컴포넌트 사이에 결합을 분리하여 테스트와 유지보수 및 코드 변경을 쉽게 만듭니다. 또한 동작에 대한 추론이 쉬워져 시스템 전반적인 설계를 개선할 수 있습니다.

이 원칙은 시스템 아키텍처 설계와 같은 대규모 작업에서 널리 사용되지만, 코드 레벨에서도 사용할 수 있습니다.

명령과 조회 책임 분리 원칙은 수정과 조회의 관점에서 시스템을 분리하여 확장성과 유지보수성을 높이고, 전체 구조를 단순하게 만들어주는 디자인 패턴입니다. 리액트 Context API와 사용자 정의 훅을 사용하여 깔끔하게 분리할 수 있었고, 각각의 책임을 효과적으로 나눌 수 있었습니다. 이러한 접근 방식은 코드 가독성을 향상시킬 뿐만 아니라 이후에 애플리케이션의 확장과 관리를 용이하게 만듭니다.
