# 리액트 컴포넌트 설계하기

먼저 단일 책임 원칙을 소개합니다. 각각의 컴포넌트는 하나의 특정한 목적을 가져야 함을 강조하는 원칙입니다.
이 원칙을 준수하면 컴포넌트를 테스트하고 유지보수하기 쉬우며, 코드를 더 읽기 쉽게 관리할 수 있습니다.

다음으로 중복 배제 원칙에 대해 다룹니다. 효과적인 프로그래밍을 위한 핵심 원칙 중 하나로, 중복을 최소화하고 재사용성을 높여줍니다.
리액트에서 이 원칙은 간소화되고 효율적이며 유지보수 가능한 코드베이스를 만드는 중요한 내용입니다.

마지막으로 컴포넌트 합성 원칙을 알아볼 것입니다. 이 원칙을 이해하면, 단순하고 재사용 가능한 컴포넌트를 조합하여 복잡한 UI를 구성할 수 있습니다.
리액트에서는 상송보다 합성을 선호하며, 합성을 통해 더욱 유연하고 다루기 쉬운 컴포넌트를 만들 수 있습니다.

- 단일 책임 원칙
- 중복 배제 원칙
- 합성 활용하기
- 컴포넌트 설계 원칙의 결합

## 4.1 단일 책임 원칙

단일 책임 원칙(SRP)은 소프트웨어 공학의 기본 개념 중 하나로 함수, 클래스 혹은 리액트 컴포넌트는 변경해야 할 이유가 단 하나만 있어야 함을 의미합니다.
다시 말해, 하나의 컴포넌트는 하나의 작업이나 기능만을 수행하는 것이 이상적입니다. 이 원칙을 따르면 코드 가독성이 높아지고, 유지보수와 테스트 및 디버깅도 쉬워집니다.

이 원칙은 각각의 컴포넌트 하나의 기능을 담당하도록 하여, 코드를 이해하기 쉽고 유지보수하기 쉽게 만들어줍니다.

## 4.2 중복 배제 원칙

중복 배제(DRY) 원칙은 소프트웨어 개발의 기본 개념 중 하나로, 코드 안에서 중복을 줄이는 것이 목적입니다.
이 원칙을 지키면 유지보수성과 가독성이 높아지고 테스트하기 쉬워지며 로직 중복으로 인해 발생하는 버그를 방지할 수 있습니다.
변경은 한 곳에서만 일어나므로 버그가 발생할 가능성이 줄어듭니다. 만약 새로운 기능을 추가한다면 하나의 컴포넌트만 수정하면 됩니다.

이 원칙은 코드의 중복을 제거하여 불일치와 버그의 가능성을 줄여줍니다. 코드 중복을 피하면, 기능 변경을 한 곳에서 해결할 수 있기 때문에 유지보수가 단순해질 수 있습니다.

## 4.3 합성 활용하기

리액트에서 합성은 컴포넌트를 설계하는 자연스러운 패턴입니다.

컴포넌트에 사용자의 프로필 정보와 친구 목록, 최근 포스트 목록을 표시하며

```jsx
<div>
  <h1>{user.name}</h1>
  <img src={user.avatar} alt="profile" />
  <h2>Friends</h2>
  <ul>
    {friends.map((friend) => (
      <li key={friend}>{friend}</li>
    ))}
  </ul>
  <h2>Latest Posts</h2>
  {posts.map((post) => (
    <div key={post.author}>
      <h3>{post.author}</h3>
      <p>{post.summary}</p>
    </div>
  ))}
</div>
```

이 예제에서 사용자의 프로필 정보와 친구 목록, 최근 포스트 목록을 표시하며, 이는 단일 책임 원칙을 위반합니다.
이것을 더욱 작은 컴포넌트로 쪼개고 각각에 하나의 책임만을 가져야 합니다.

먼저 프로필과 관련된 JSX를 추출하여 사용자 프로필을 나타내는 컴포넌트로 분리합니다.

```jsx
function UserProfile({ user }) {
  return (
    <>
      <h1>{user.name}</h1>
      <img src={user.avatar} alt="profile" />
    </>
  );
}
```

이제 친구 목록과 관련된 JSX를 추출하여 친구 목록을 나타내는 컴포넌트로 분리합니다.

```jsx
function UserFriends({ friends }) {
  return (
    <>
      <h2>Friends</h2>
      <ul>
        {friends.map((friend) => (
          <li key={friend}>{friend}</li>
        ))}
      </ul>
    </>
  );
}
```

마지막으로 최근 포스트 목록과 관련된 JSX를 추출하여 최근 포스트 목록을 나타내는 컴포넌트로 분리합니다.

```jsx
function UserPosts({ posts }) {
  return (
    <>
      <h2>Latest Posts</h2>
      {posts.map((post) => (
        <div key={post.author}>
          <h3>{post.author}</h3>
          <p>{post.summary}</p>
        </div>
      ))}
    </>
  );
}
```

이제 메인 컴포넌트는 단순해졌고, 역할을 작은 컴포넌트들에 위임했습니다.

```jsx
function User({ user, friends, posts }) {
  return (
    <>
      <UserProfile user={user} />
      <UserFriends friends={friends} />
      <UserPosts posts={posts} />
    </>
  );
}
```

리팩터링한 컴포넌트는 여러 가지 장점이 있습니다.

- **관심사 분리**: 컴포넌트의 여러 다른 영역들을 분리해서 각각의 컴포넌트가 하나의 역할을 담당합니다. 덕분에 유지보수가 쉬워집니다.
- **더 나은 가독성**: 리팩터링한 컴포넌트는 가독성이 높아 이해하기 쉽습니다. 사용자 프로필, 친구 목록, 포스트 목록 등 컴포넌트가 어떤 것을 렌더링할지 명확합니다. 각 영역이 어디서 어떻게 렌더링 되는지 세세하게 살펴볼 필요가 없습니다.
- **높은 재사용성**: 분리시킨 컴포넌트를 애플리케이션의 다른 영역에서도 사용할 수 있기 때문에 중복을 줄일 수 있습니다.
- **테스트의 용이함**: 작고 하나의 책임을 가진 컴포넌트는 상호작용이 복잡하지 않고 의존하는 코드가 적어 테스트하기 쉽습니다.

이 예제는 단순하지만, 리액트에서 합성에 대한 기본 개념을 잘 보여줍니다. 내부에 상태와 로직을 가진 컴포넌트를 다루다 보면 합성은 더 복잡해질 것입니다. 하지만 재사용이 가능한 작은 컴포넌트를 결합하여 큰 컴포넌트를 만든다는 핵심 원칙은 동일하게 적용됩니다.

단순하고 하나의 기능을 가진 컴포넌트들의 합성을 통해 복잡한 사용자 인터페이스를 효과적으로 구조화할 수 있습니다.
합성을 사용해서 단일 책임 원칙과 중복 배제 원칙을 온전하게 구현할 수 있고, 이해와 유지보수가 쉽고 테스트가 용이한 정교한 UI를 만들 수 있습니다.

## 4.4 컴포넌트 설계 원칙의 결합

컴포넌트가 보통 5개 이상의 prop을 가진다면 분리가 필요합니다.
각 prop의 용도를 기억하기 쉽지 않을 수 있고, 잘못된 prop을 전달하거나 전달 순서가 틀릴 수 있기 때문입니다.

커다란 컴포넌트를 작게 나누는 방법은 다양합니다. 정보가 서로 관련되어 있다면 하나의 그룹으로 묶고 이 단위로 새로운 컴포넌트를 만듭니다.

이러한 컴포넌트 설계 원칙들을 결합하여 사용하면, 리액트 애플리케이션을 더욱 효율적으로 구축할 수 있습니다.
