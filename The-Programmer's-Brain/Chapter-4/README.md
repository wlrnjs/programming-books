# 프로그래밍 문법 빠르게 배우기

## 이 장에서는 다음과 같은 내용을 다룬다.

- 작업 기억 공간이 복잡한 코드에 의해 과부하가 걸릴 때 어떤 일이 일어나는지 분석
- 프로그래밍에서 두 가지 종류의 작업 기억 공간 과부하
- 과부하가 걸린 작업 기억 공간을 보상하기 위해 읽기 쉬운 코드로 리팩터링하는 법
- 복잡한 코드를 읽을 때 작업 기억 공간을 지원하기 위한 상태표와 의존 그래프 생성하기

1장에서 코드를 읽을 때 혼란이 발생하는 세 가지 방식에 대해 살펴봤다. 코드가 혼란스러운 이유는 첫째, STM에 저장되어 있어야 할 정보가 부족하기 때문이거나, 둘째, LTM에 저장되어 있는 지식이 부족하기 때문이다. 이 장에서는 세 번째 이유에 대해 다루려고 한다. 그것은 바로 두뇌의 처리 능력 부족이다.

## 4.1 복잡한 코드를 이해하는 것이 왜 어려울까?

### 4.1.1 작업 기억 공간과 STM의 차이

STM의 역할이 정보를 기억하는 것인 반면, 작업 기억 공간의 역할은 정보를 처리하는 것이다.
2장에서 살펴봤듯이 STM은 한 번에 2개에서 6개까지의 항목만 저장할 수 있다. 정보가 단어나 체스 오프닝, 디자인 패턴과 같이 인식 가능한 청크로 나누어질 때는 더 많은 정보를 처리할 수 있다. 작업 기억 공간도 특정한 문제에 적용된 STM이기 때문에 STM과 같은 제한이 있다.

STM과 같이 작업 기억 공간도 한 번에 2개에서 6개까지만 기억할 수 있다. 작업 기억 공간의 맥락에서 이 용량을 인지 부하 cognitive load라고 부른다. 너무 많은 요소가 있어 청크로 나뉘지 않는 문제를 풀려고 할 때 작업 기억 공간은 과부하 상태가 된다.

### 4.1.2 프로그래밍과 관련한 인지 부하의 종류

인지 부하를 체계적으로 다루기 전에 먼저 인지 부하의 여러 종류를 먼저 살펴볼 필요가 있다.
인지 부하 이론은 오스트레일리아의 존 스웰러 교수가 처음 제안했다. 스웰러는 인지 부하를 내재적 intrinsic, 외재적 extraneous, 본유적 germane 세 가지로 구별했다.

인지 부하의 종류
부하 종류 | 간략한 설명
-------- | --------
내재적 부하 | 문제 자체가 얼마나 복잡한지
외재적 부하 | 외부적 요인에 의해 문제에 추가된 것
본유적 부하 | 생각을 LTM에 저장하는 과정에서 일어나는 인지 부하

#### 코드를 읽을 때 내재적 인지 부하

**내재적 인지 부하**는 문제 그 자체가 갖는 특성 때문에 발생하는 인지 부하다.

예를 들어 직각삼각형의 빗변의 길이를 계산한다고 가정해보자.
이 계산 문제는 문제에 원래부터 존재하는 특징이 있다. 예를 들면 이 문제를 풀려면 피타고라스의 정리를 알고 있는 상태에서 계산해야 한다.
이 문제를 풀 다른 방법은 존재하지 않으며 이 단계를 간단하게 하는 방법도 없기 때문에 이 문제의 부하는 문제에 내재해 있다.

프로그래밍에서는 **내재적 복잡성**이라는 용어를 사용해서 문제의 내재적 측면을 설명한다.
인지과학에서는 이렇게 문제 자체에 존재하는 특성이 내재적 인지 부하의 원인이라고 말한다.

#### 코드를 읽을 때 외재적 인지 부하

어떤 문제가 두뇌에 일으키는 자연적이고 내재적인 부하에 '더해서' 문제에 추가되는 인지 부하다. 종종 우연히 이루어진다.

예를 들면 빗변의 길이를 계산하는 것을 다른 방식으로 만들었다. 그러면 삼각형의 두 변 a와 b라는 레이블을 연결시켜야 한다.
이러한 추가적인 작업 때문에 더 큰 **외재적 인지 부하**가 발생한다.

문제가 실제로 어려워진 것은 아니다. 여전히 피타고라스 정리를 외우고 적용하면 된다. 하지만 우리 두뇌는 a와 b를 연결하는 외재적 업무를 추가로 수행해야 한다.
이러한 부하는 프로그래밍의 우발적 복잡성과 유사하다.

외재적 부하는 프로그래머에 따라 다르다. 특정 개념을 많이 경험할수록 그것에 대한 인지 부하는 적어진다.

### 4.2 인지 부하를 줄이기 위한 기법

코드가 작업 기억 공간에 과부하를 초래하는 다양한 방식에 대해 살펴봤으므로 인지 부하를 줄이는 방법에 대해 알아보자.
이 장의 나머지 부분에서는 복잡한 코드를 쉽게 읽을 세 가지 방법에 대해 논의한다. 첫 번째 방법은 다른 맥락에서 이미 알고 있을지도 모르겠지만, 리팩터링이다.

#### 리팩터링

**리팩터링**은 코드가 외부적으로 제공하는 기능은 유지한 채 코드의 내부 구조를 개선하는 것을 의미한다.
리팩터링의 예로는 어떤 코드 블록의 길이가 너무 길면 여러 개의 함수로 나누거나 재사용을 위해 중복된 코드를 하나로 통합하는 것이다.

대개의 경우 리팩터링은 코드의 유지 보수를 쉽게 하기 위한 목적으로 이루어진다.
예를 들면 중복된 코드를 제거하고 나면 이후에 해당 코드를 수정해야 하는 경우 한 곳만 수정하면 된다.

하지만 코드가 전체적으로 유지 보수하기 좋게 수정됐다고 해서 가독성까지 반드시 좋아지는 것은 아니다.

예를 들어 메서드 호출이 많은 코드를 생각해보자. 이 메서드가 같은 파일 혹은 여러 파일에 걸쳐서 존재하는 메서드라면 이 코드는 모든 로직이 각자의 메서드에 따로 구현되어 있기 때문에 유지 보수하기에는 좋은 코드다. 하지만 이렇게 탈국지화된 코드는 여러 군데에서 메서드의 내부 구현을 찾아봐야 하기 때문에 작업 기억 공간에는 어려움을 줄 수 있다.

따라서 유지 보수하기 좋은 코드를 작성하기보다는 장기적으로 가독성이 높은 코드를 작성하도록 리팩터링하는 것이 좋을 수도 있다. 이런 방식의 리팩터링을 **인지적 리팩터링**이라고 정의한다. 인지적 리팩터링은 일반적인 리팩터링과 동일하게 코드가 외부로 제공하는 기능을 변경하지는 않는다. 다만, 인지적 리팩터링의 목표는 유지 보수하기 좋은 코드로 변경하는 것이 아니라 현 시점에서 개발자가 읽기 쉬운 코드로 변경하는 것이다.

인지적 리팩터링은 때로는 **역 리팩터링**을 수반할 수도 있다. 즉 오히려 코드의 유지 보수성을 더 낮추는 결과를 가져올 수도 있다. 예를 들어 메서드를 따로 정의하지 않고 해당 라인에 바로 구현하는 **인라인** 메서드는 가독성은 증진되는 반면 유지 보수성은 떨어진다.

메서드를 인라인으로 구현하면 외재적 인지 부하를 낮추고 코드를 이해하는 데 도움이 된다. 이에 더해 좀 더 많은 배경 정보로 인해 코드 파악을 쉽게 할 수 있다. 또한 새로운 맥락에서 그 메서드의 이름을 더 적절하게 변경할 수도 있다.

또 다른 방법으로는 코드 내에서 메서드의 순서를 변경할 수도 있다. 예를 들어 어떤 메서드가 최초로 호출되는 위치로부터 가까이 정의되어 있다면 코드의 가독성이 좋아진다.
물론 많은 IDE가 메서드나 함수의 정의로 손쉽게 이동할 수 있는 기능을 제공하지만 정의를 확인하는 일은 여전히 작업 기억 공간을 사용하고 외재적 인지 부하를 유발할 수 있다.

사람마다 지식에 따라 코드의 이해도가 달라지고 리팩터링하는 내용도 달라지기 때문에 인지적 리팩터링은 개발자 자신만을 위한 리팩터링이다. 많은 경우 인지적 리팩터링은 일시적이고 자신이 코드를 이해하는 게 목적이므로 일단 이해하고 나면 코드를 원래 상태로 되돌릴 수도 있다.

#### 4.2.2 생소한 언어 구성 요소를 다른 것으로 대치하기

코드를 읽을 때 혼란이 되는 세 가지 원인 ,즉 지식 부족, 정보 부족, 처리 능력 부족을 극복하는 데 도움이 되는 기법에 대해 다뤄보겠다. 코드에 있는 프로그래밍 개념이 익숙하지 않다면 지식의 부족 문제를 겪을 것이다. 이 경우 도움이 될 수 있는 방법을 먼저 살펴보겠다.

어떤 상황에서는 익숙하지 않은 프로그래밍 언어의 구성 요소를 이것과는 다르지만 좀 더 익숙한 방식으로 표현할 수 있다. 예를 들어 자바나 C# 같은 현대의 많은 프로그래밍 언어는 **람다**라고도 하는 **익명 함수**를 지원한다. 람다는 이름이 없는 함수다(그래서 무명 혹은 익명 함수라고 부른다.) 또 다른 예로 파이썬의 리스트 컴프리헨션이 있다. 람다와 리스트 컴프리헨션은 간단하고 가독성 높은 코드를 만들 때 유용하지만 많은 프로그래머는 람다에 익숙하지 않으며 for 루프나 while 루프를 읽고 이해하는 것보다 어려워한다.

읽거나 작성하는 코드가 간단하고 명확하면 람다나 리스트 컴프리헨션이 문제되지 않지만, 복잡한 코드의 경우에는 작업 기억 공간에 과부하가 발생한다. 익숙하지 않은 언어 구성 요소는 작업 기억 공간에 외재적 인지 부하를 늘리기 때문에 복잡한 코드를 읽을 때는 이들로 인한 부하가 늘어나지 않게 하는 것이 좋다.

물론 정확하게 어떤 언어 구성 요소를 대치할지는 어떤 지식을 가지고 있느냐에 달려 있지만, 인지 부하를 줄이기 위해 다른 코드로 대치하려는 이유는 두 가지가 있다.
첫 번째는 이 언어 구성 요소들이 이해하기 어렵기 떄문이고, 두 번째로는 더 기본적인 문법으로 같은 기능을 수행하는 것이기 때문이다.

람다와 리스트 컴프리헨션은 이 두 가지에 다 해당하기 때문에 이 기법을 설명하기에 적합하다. 람다와 리스트 컴프리헨션으로 작성된 코드가 있다면 이들에 대해 더 잘 이해할 때까지 이들을 for 루프 혹은 while 루프로 바꿔서 인지 부하를 줄이면 유용할 때가 있다. 삼항 연산자 역시 인지 부하를 줄이기 위한 리팩터링의 좋은 후보다.

#### 삼항 연산자

개념적으로 삼항 연산자는 이해하기 어렵지 않다. 전문 프로그래머라면 조건문에 친숙할 것이다. 하지만 연산이 한 라인에서 이루어진다는 점이나 인수의 순서가 다른 전통적인 언어의 if문과는 다르다는 점 때문에 외재적 인지 부하가 과도하게 일어날 수 있다.

어떤 사람들에게는 앞 섹션에서 설명한 리팩터링이 이상하거나 잘못된 것처럼 보일 수도 있다. 람다나 삼항 연산자는 코드의 가독성을 높여주기 때문에 이것을 사용하는 것은 언제나 바람직하다고 생각할 수도 있다. 더 바람직하지 않은 상태로 코드를 리팩터링하는 것에 어쩌면 반대할지도 모르겠다. 하지만 이 장과 이책의 앞부분에서 살펴봤듯이 '가독성'이라는 것은 보는 사람의 눈에 읽기 좋다는 의미이다. 삼항 연산자에 익숙하다면 그것을 사용한 코드는 읽기 쉽다. 무엇이 읽기 쉬운지는 이미 가지고 있는 지식에 따라 다르기 때문에 좀 더 친숙한 형태로 코드를 바꿔서 이해하는 것은 부끄러운 일이 아니다.

## 요약

- 인지 부하는 작업 기억 공간이 처리할 수 있는 한계를 나타낸다. 인지 부하가 너무 크면 두뇌가 코드를 적절하게 처리할 수 없다.
- 프로그래밍과 관련해 두 가지 종류의 인지 부하가 있다. 내재적 인지 부하는 코드에 존재하는 복잡성에 기인하고 외재적 인지 부하는 우발적으로(코드가 표현되는 방식에 의해) 혹은 코드를 읽는 개발자의 지식의 부족에 기인한다.
- 리팩터링은 코드를 읽는 사람이 이미 가지고 있는 지식에 맞춰 코드를 변경함으로써 외재적 인지 부하를 줄이는 방법이다.
