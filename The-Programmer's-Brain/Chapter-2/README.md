# 신속한 코드 분석

## 이 장에서는 다음과 같은 내용을 다룬다.

- 경험 많은 개발자조차 코드를 빨리 이해하는 것이 어려운 이유
- 두뇌가 정보들을 어떻게 인식 가능한 부분으로 나누는지에 대한 이해
- 단어와 코드 같은 정보를 분석할 때 **LTM**과 **STM** 사이의 상호작용
- 코드 분석 시 영상 기억 공간의 역할
- 코드 기억을 통한 코딩 수준의 자가 진단
- 읽기 쉬운 코드를 작성하는 법

이 장에서는 코드를 읽는 것에 관해 집중적으로 살펴본다.
프로그래머가 일하는 시간 중 코드를 읽고 분석하는 일은 생각보다 많다.
연구에 의하면 프로그래머의 시간 중 거의 60%를 코드를 '작성'하는 게 아니라 '이해'하는 데 사용한다고 한다.
따라서 정확도를 유지하면서 코드를 빨리 이해하도록 향상한다면 프로그래밍 기술이 크게 개선되는 셈이다.

---

## 2.1 코드를 신속하게 읽기

해럴드 아벨슨, 제럴드 제이 서스먼, 줄리 서스먼이 쓴 <컴퓨터 프로그램의 구조와 해석>에 다음과 같은 유명한 문장이 있다.
"프로그램은 사람이 읽을 수 있도록 작성해야만 한다. 기계가 실행하는 것은 부차적인 일이다." 이 말이 사실임에도 현실적으로 프로그래머들은 코드를 읽는 법보다 작성하는 범을 훨씬 더 많이 연습한다.

코드를 읽는 목적은 다양하다. 예를 들어 기능을 추가하거나 버그를 발견하기 위해서 혹은 코드가 실행될 더 큰 시스템을 이해하기 위해서다. 이 모든 상황에서 한 가지 공통점은 코드를 읽을 때 우리는 그 코드에 존재하는 특정한 정보를 찾는다는 점이다. 차는 정보의 예로는 새로운 기능을 추가할 적당한 부분, 마지막으로 수정한 코드 중 특정 버그가 있을 만한 곳, 특정 메서드가 어떻게 구현됐는지 등이 있다.

### 2.1.1 두뇌에서 무슨 일이 일어나는가?

코드를 읽느 과정에서 어떤 정보들은 **STM**에 저장된다. **LTM**은 두 가지 방법으로 여기에 정보를 추가한다. 첫째, 언어의 문법에 대한 지식은 **LTM**으로부터 가져온다. **LTM**은 배열에 대해 for 루프 문법을 기억한다. 배열에 있는 모든 원소를 프린트 하는 문법까지 기억할 수 있다.

두 번째로, 코드가 어떤 기능을 구현한다는 사실을 알고 있다는 점이다. 이 사실을 알기 때문에 코드르 다시 작성할 때 기억이 나지 않는 부분이 있으면, 그 점을 이용해 기억나지 않는 부분을 작성할 수 있다.

### 2.1.4 생소한 코드를 읽는 것은 왜 어려운가?

가장 결정적인 이유는 **STM**의 용량에 제한이 있기 때문이다.

코드에 있는 정보를 모두 다 **STM**에 저장하고 처리하는 것은 물리적으로 불가능하다. 1장에서 살펴봤듯이 **STM**은 읽거나 들은 정보를 짧은 시간만 저장한다.
여기서 짧은 시간이라는 것은 정말로 짧은 시간을 의미하는데 연구에 의하면 30초를 넘지 않는다. 30초 후에 그 정보는 LTM에 저장되거나 잊힌다.

**STM**은 정보를 저장하는 시간뿐만 아니라 크기 또한 제약된다.
컴퓨터와 비슷하게, 우리 두뇌에서 **LTM**은 **STM**보다 기억 용량이 훨씬 더 크다. 하지만 컴퓨터의 메인 메모리는 몇 기가바이트라도 되지만 두뇌에서 **STM**의 용량은 불과 몇 개 정도밖에 되지 않는다.

최근 연구에서는 **STM**의 용량이 2개에서 6개 사이로 심지어 더 적다고 추정한다.이 용량은 거의 대부분의 사람에게 해당하고, 과학자들은 **STM**의 용량을 향상하는 방법을 아직 찾지 못했다.

## 2.2 기억의 크기 제한을 극복하기

### 2.2.1 단위로 묶는 것의 위력

네덜란드 수학자 아드리안 더흐로트는 **청크**라는 개념을 처음 사용했다. 수학과 박사 과정에 있었던 더흐로트는 체스를 열렬하게 좋아했다.
이 수학자는 전문 선수인 체스 마스터와 평범한 체스 플레이어로 이루어진 그룹을 만들어서 비교를 했다.

첫 번째 실험에서는 체스에서 자주 나오는 장면을 예시로, 테스트 A에서는 체스 마스터가 훨씬 더 잘 기억해냈다.
두 번째 실험에서는 체스에서 자주 나오지 않는 장면을 예시로 테스트 B를 진행했다.
이때는 체스 마스터와 평범한 체스 플레이어가 모두 제대로 기억하지 못했다.

이 실험 결과를 통해 **STM**의 용량은 제한적이지만 **LTM**에 지식이 많으면 기억을 쉽게 한다는 사실은 프로그래밍에도 해당된다.

### 2.3 읽는 것보다 보는 것이 더 많다

**STM**을 자세히 다루기 전에 먼저 정보가 두뇌로 들어오면 어떤 일이 일어나는지 살펴보자.
정보는 **STM**에 도달하기 전에 **감각 기억 공간**이라는 영역을 통과한다.

감각 기억 공간은, 컴퓨터에 비유하면 마우스나 키보드 같은 입력장치와 통신하는 입출력 버퍼라고 볼 수 있다.
주변장치로부터 전송된 정보는 입출력 버퍼에 잠시 저장되는데, 감각 기억 공간에서도 같은 일이 일어난다.
시각이나 청각 정보 혹은 촉각에 의한 정보가 여기에 잠시 저장된다.
감각 기억 공간에는 시각, 청각, 미각, 후각, 촉각에 대해 각자의 임시 저장 공간이 있다.
이들 감각이 다 프로그래밍과 관련 있는 것은 아니기에 이 장에서는 **영상 기억 공간**이라는 시각 관련 기억 공간에 대해서만 다룬다.

### 2.3.1 영상 기억 공간

정보가 감각기관을 통해 들어오면 **STM**으로 전달되기 전에 감각 기억 공간에 저장된다.
코드를 읽을 때에는 우리 눈을 통해 정보가 들어오는데 이 정보는 영상 기억 공간에 잠시 저장된다.

### 2.3.2 기억하는 대상이 중요한 것이 아니고 기억하는 방식이 중요하다

더흐로트의 연구를 알골 언어에 적용했던 연구팀은 다른 실험도 수행했고, 이 실험 결과를 통해 청킹에 대한 통찰을 얻을 수 있다.
이 실험에서 초급, 중금, 고급 프로그래머들은 IF, TRUE, END 같은 총 21개의 알골 언어 키워드를 기억하도록 교육받았다.
매키던과 그의 연구팀은 실험 참가자들이 키워드를 작성하는 순서에 주목했는데 이것을 통해 피 실험자들이 키워드 간에 만들어내는 연관성에 대해 깊이 이해할 수 있었다. 연구 결과를 보면, 초급 프로그래머들은 숙련된 프로그래머들과는 다른 방식으로 알골 키워드를 그룹 지었다. 예를 들어 기억하는 데 도움이 되도록 "TRUE IS REAL THEN FALSE" 같은 문장을 만들어 사용했다. 하지만 숙련된 프로그래머들은 키워드를 그룹 지을 때 이미 가지고 있는 지식을 사용했는데, 예를 들면 TRUE와 FALSE를 같이 묶고ㅡ IF, THEN, ELSE를 같이 묶었다. 이 실험을 통해 전문가와 초보자가 코드에 대해 생각하는 방식이 다르다는 것을 다시 한번 확인할 수 있었다.

#### 청크로 묶을 수 있는 코드를 작성하는 방법

앞서 해봤던 기억-청크 연습을 몇 번 해보면 코드를 어떻게 여러 그룹으로 묶을 수 있는지 알 수 있을 것이다.
체스 플레이어를 대상으로 한 더흐로트의 실험을 통해, 일상적이고 예상 가능한 상황은 청크로 묶는 것을 쉽게 한다는 것을 알게 되었다.

#### 디자인 패턴의 사용

그룹으로 묶기 쉬운 코드를 작성하려면 디자인 패턴을 사용하면 된다. 이 방안은 독일의 카를스루에 공과대학교의 컴퓨터 과학 교수인 발터 티히가 제안한 것이다.

이 실험에서는 개발자를 대상으로 디자인 패턴 교육을 듣게 했다. 디자인 패턴에 대한 교육을 받은 후에 코드를 수정할 때는 패턴을 사용하는 코드에 대해서는 수정 시간이 줄어든 반면, 패턴을 사용하지 않은 코드에 대해서는 차이가 없었다. 디자인 패턴에 대한 지식을 갖게 되면 청킹 능력이 향상되고 코드를 더 빠르게 수정할 수 있게 된다는 점을 이 연구를 통해 알 수 있다. 또한 디자인 패턴에 따라 차이가 있다는 것도 알 수 있는데 데코레이터 패턴보다 옵서버 패턴을 수정할 때 시간 단축이 더 컸다.

#### 주석문 쓰기

연구 결과에 의하면 코드가 주석문을 포함하고 있으면 개발자들이 코드를 읽는 시간이 더 많이 들어간다고 한다. 주석문은 코드를 읽는 시간을 늘리기 때문에 바람직하지 않은 것이라고 생각할지도 모르겠지만, 사실 이는 개발자들이 코드를 읽을 때 주석문 역시 읽는다는 것을 시사한다. 이것은 최소한, 주석문을 작성하는 것이 전혀 의미 없는 일이 아니라는 것을 보여준다.

#### 표식 남기기

코드를 청크로 쉽게 쪼개는 데 도움이 되는 마지막 사항은 코드에 어떤 **표식**을 남기는 것이다. 표식은 개발자가 코드를 읽을 때 그 코드가 무엇을 하는지 이해하는 데 도움이 된다. 표식은 코드에서 한 라인이 될 수도 있고 한 라인의 일부가 될 수도 있는데, 코드를 읽다가 속으로 '아, 이거구나'라는 생각이 들면 그게 바로 표식이다.

표식은 일반적으로 코드 내에서 사용하는 특정 자료구조, 알고리즘, 혹은 접근 방식 등을 보여주는 라인을 뜻한다.

```python
# 트리에서 한 노드를 나타내는 클래스

class Node:
  def __int__(self, key):
    self.left = None
    self.right = None
    self.val = key

#중위 순위 함수
def print_in_order(root):
  if root:

    # 왼쪽 자식에 대한 첫 번째 재귀 호출
    print_in_order(root.left)

    # 노드 데이터 출력
    print(root.val)

    # 오른쪽 자식에 대한 재귀 호출
    print_in_order(root.right)

print("트리의 내용은 다음과 같다.")
print_in_order(tree)
```

이 파이썬 코드는 다음과 같은 몇 가지 표식을 가지고 있어 개발자가 코드를 읽을 때 이진 트리가 자료구조로 사용된다는 사실을 이 표식으로부터 유추할 수 있다.

- 주석문에 단어 '트리'를 사용
- root와 tree라는 변수명
- left와 right라는 필드명
- 트리에 관한 문자열 값("트리의 내용은 다음과 같다.")

표식은 코드를 읽고 이해하는 과정에서 소스 코드에 대해 개발자가 갖는 가정이 맞거나 틀린 것을 확인해주는 역할을 수행하기 때문에 매우중요하다.
앞의 파이썬 예제 코드를 읽을 때 처음에는 코드가 무슨 일을 하는지 알지 못할 수도 있다. 첫 번째 주석문과 Node 클래스를 보게 되면 이 코드가 트리에 관한 것임을 알게 된다.
필드명 left와 right를 통해 트리 중에서도 범위를 더 좁혀서 이진 트리에 대한 것임을 알게 된다.

표식에는 **단순 표식**simple beacon과 **복합 표식**compound beacon 두 가지 종류가 있다.

단순 표식은 의미 있는 변수명같이 코드의 문법을 통해 의미가 자명한 표식이다.

복합 표식은 단순 표식으로 이루어진 좀 더 큰 단위의 코드로, 단순 표식들이 모여 함께 실행하는 기능에 대해 알려준다.
앞의 코드에서 self.left와 self.right는 둘이 합쳐 하나의 복합 표식을 형성한다.
각각 개별적으로는 별로 의미가 없으나 같이 보면 의미가 있다. 코드의 요소들 또한 복합 표식의 기능을 갖는다. for 루프는 변수 선언, 초기화, 값의 변화, 경계 조건을 포함하기 때문에 복합 표식이다.

표식은 여러 형태가 될 수 있다. 변수명이나 클래스명, 메서드명 같은 식별자 역시 표식이 될 수 있다는 것을 기억해두자.

### 2.3.3 청킹 연습

이 장에서 소개한 연구에 의하면 경험이 많은 사람은 체스 말이나 단어 혹은 코드에 대해 좀 더 많은 것을 기억한다. 경험이 쌓이면서 프로그래밍에 대한 지식이 자연스럽게 늘어나긴 하지만,
코드 청킹을 의도적으로 연습하는 방법이 몇 가지 있다.

이 책의 많은 부분에서 **의도적 연습**이라는 문구가 있는데, 의도적 연습은 어떤 기술을 향상하기 위해 조금씩 연습하는 것을 의미한다.
팔의 근육을 늘리기 위해 하는 푸쉬업은 의도적 연습이다. 프로그래밍에서는 여러 가지 이유로 의도적 연습이 흔치는 않다.
많은 사람이 코드를 많이 작성해보는 것으로 프로그래밍을 학습한다. 그렇게 해도 되지만 효과적인 방법은 아닐 수도 있다. 청킹을 의도적으로 연습하기 위해서는 적극적으로 코드를 기억해내는 것을 훈련하면 아주 좋다.
